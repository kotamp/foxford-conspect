<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>24. Ссылочная реализация структур данных - двоичное дерево поиска</title></head><body><h1>24. Ссылочная реализация структур данных - двоичное дерево поиска</h1>
<div class="page_content_main"><h2>Двоичное дерево поиска</h2>
<p>В ссылочных реализациях структур данных данные хранятся в виде отдельных элементов, связанных между собой указателями. Элементы организованы либо в виде последовательности (списка), либо в виде дерева. Рассмотрим организацию ссылочной структуры данных на основе двоичного дерева поиска.</p>
<p>В двоичном дереве поиска хранятся элементы, которые можно сравнивать между собой при помощи операций "меньше" и "больше", например, это могут быть числа или строки.</p>
<p>Все элементы, которые хранятся в дереве - уникальные, то есть одно число не может быть записано в двух вершинах дерева. У каждой вершины дерева есть два поддерева - левое и правое (они могут быть и пустыми), причем в левом поддереве все элементы меньше значения, записанного в данной вершине, а в правом поддереве - больше.</p>
<p>Пример правильно построенного двоичного дерева поиска:</p>
<p><img src="https://server.179.ru/tasks/cpp/2013b1/images/binary_tree.gif" align="middle"></p>
<p>Благодаря такому представлению, все операции с деревом (поиск элемента, добавление элемента, удаление элемента) выполняются за время, пропорциональное высоте дерева, а не его размеру. Это позволяет (используя специальные алгоритмы балансировки дерева) реализовать эффективные структуры данных типа "множество", в которых все операции осуществляются за <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>log</mi><mo>&amp;#x2061;</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.336ex" height="2.776ex" viewBox="0 -817.1 3589.2 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="#MJMAIN-6C"></use><use xlink:href="#MJMAIN-6F" x="278" y="0"></use><use xlink:href="#MJMAIN-67" x="779" y="0"></use></g><use xlink:href="#MJMATHI-6E" x="2599" y="0"></use><use xlink:href="#MJMAIN-29" x="3199" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1">O(\log n)</script>, где <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.611ex" viewBox="0 -566.3 600.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-2">n</script> — количество элементов в множестве.</p><h2>Объявление классов tree_elem и binary_tree</h2>
<p>Для представления одной вершины (узла) двоичного дерева поиска создадим класс <span class="page_code_style">tree_elem</span>. У элементов этого класса будут следующие поля:</p>
<p><span class="page_code_style">m_data</span> - данные (число), которые хранятся в этой вершине.</p>
<p><span class="page_code_style">m_left</span> - указатель на левого потомка данной вершины.</p>
<p><span class="page_code_style">m_right</span> - указатель на правого потомка данной вершины.</p>
<div class="page_code_style">class tree_elem<br>{<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp;&nbsp; int m_data;<br>&nbsp;&nbsp;&nbsp;&nbsp; tree_elem * m_left;<br>&nbsp;&nbsp;&nbsp;&nbsp; tree_elem * m_right;<br>&nbsp;&nbsp;&nbsp;&nbsp; tree_elem(int val)<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_left = NULL; // В С++11 лучше использовать nullptr<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_right = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_data = val;<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>};</div>
<p>Конструктор для данного класса создает элемент, записывает в него переданные данные, левые и правые поддеревья инициализирует нулевыми указателями.</p>
<p>Рассмотрим описание класса <span class="page_code_style">binary_tree</span>.</p>
<div class="page_code_style">class binary_tree<br>{<br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; tree_elem * m_root;<br>&nbsp;&nbsp;&nbsp; int m_size;<br>&nbsp;&nbsp;&nbsp; void print_tree(tree_elem *);<br>&nbsp;&nbsp;&nbsp; void delete_tree(tree_elem *);<br><br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; binary_tree(int);<br>&nbsp;&nbsp;&nbsp; ~binary_tree();<br>&nbsp;&nbsp;&nbsp; void print();<br>&nbsp;&nbsp;&nbsp; bool find(int);<br>&nbsp;&nbsp;&nbsp; void insert(int);<br>&nbsp;&nbsp;&nbsp; void erase(int);<br>&nbsp;&nbsp;&nbsp; int size();<br>};</div>
<p><span class="page_code_style">m_root</span> - указатель на корень дерева.</p>
<p><span class="page_code_style">m_size</span> хранит в себе количество элементов в дереве.</p>
<p>Метод <span class="page_code_style">find()</span> проверяет, содержится ли данный элемент в дереве, метод <span class="page_code_style">print()</span> выводит все элементы поддерева, метод <span class="page_code_style">insert()</span> добавляет новый элемент в дерево, метод <span class="page_code_style">erase() </span>удаляет значение из дерева, метод <span class="page_code_style">size()</span> возвращает значение.</p>
<p>Вспомогательные методы <span class="page_code_style">print_tree() </span>и <span class="page_code_style">delete_tree()</span> используются в рекурсивных алгоритмах обхода дерева и удаления дерева.</p><h2>Конструктор</h2>
<p>Конструктор класса binary_tree создает дерево из одного элемента. Для простоты будем считать, что в дереве всегда должен быть хотя бы один элемент.</p>
<div class="page_code_style">binary_tree::binary_tree(int key)<br>{<br>&nbsp;&nbsp;&nbsp; m_root = new tree_elem(key);<br>&nbsp;&nbsp;&nbsp; m_size = 1;<br>}</div><h2>Деструктор</h2>
<p>Деструктор должен удалить все элементы дерева, для каждого из них вызвав оператор <span class="page_code_style">delete</span>. Для этого реализована рекурсивная процедура <span class="page_code_style">delete_tree</span>. Она рекурсивно вызывает себя для удаления левого поддерева, правого поддерева, затем удаляет сам элемент.</p>
<p>Сам деструктор просто вызывает рекурсивную процедуру <span class="page_code_style">delete_tree</span> начиная от корня.</p>
<div class="page_code_style">binary_tree::~binary_tree()<br>{<br>&nbsp;&nbsp;&nbsp; delete_tree(m_root);<br>}<br><br>void binary_tree::delete_tree(tree_elem * curr)<br>{<br>&nbsp;&nbsp;&nbsp; if (curr)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete_tree(curr-&gt;m_left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete_tree(curr-&gt;m_right);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete curr;<br>&nbsp;&nbsp;&nbsp; }<br>}</div><h2>Обход дерева</h2>
<p>Обход дерева также реализуется рекурсивной процедурой - сначала зайдем в левое поддерево, потом в правое поддерево.</p>
<p>Метод <span class="page_code_style">print()</span> рекурсивно обходит дерево и выводит его элементы в порядке возрастания.</p>
<div class="page_code_style">void binary_tree::print()<br>{<br>&nbsp;&nbsp;&nbsp; print_tree(m_root);<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;<br>}<br><br>void binary_tree::print_tree(tree_elem * curr)<br>{<br>&nbsp;&nbsp;&nbsp; if (curr) // Проверка на ненулевой указатель<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_tree(curr-&gt;m_left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; curr-&gt;m_data &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_tree(curr-&gt;m_right);<br>&nbsp;&nbsp;&nbsp; }<br>}</div><h2>Поиск элемента в дереве</h2>
<p>Метод <span class="page_code_style">find</span> проверяет, содержится ли в дереве элемент со значением <span class="page_code_style">key</span> и возвращает <span class="page_code_style">true</span> или <span class="page_code_style">false</span>. Поиск начинается от корня. Если <span class="page_code_style">key</span> меньше того, что хранится в корне - спускаемся в левое поддерево, если больше - то в правое поддерево. Продолжаем до тех пор, пока не найдем нужный элемент, или не дойдем до пустого поддерева.</p>
<div class="page_code_style">bool binary_tree::find(int key)<br>{<br>&nbsp;&nbsp;&nbsp; tree_elem * curr = m_root;<br>&nbsp;&nbsp;&nbsp; while (curr &amp;&amp; curr-&gt;m_data != key)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curr-&gt;m_data &gt; key)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr = curr-&gt;m_left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr = curr-&gt;m_right;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return curr != NULL;<br>}</div><h2>Добавление элемента в дерево</h2>
<p>Метод добавления элемента в дерево аналогичен методу поиска элемента - ищется позиция, где может находиться данный элемент. Если элемент не найден, то нужно создать новый элемент дерева в том месте, где он должен находиться.</p>
<div class="page_code_style">void binary_tree::insert(int key)<br>{<br>&nbsp;&nbsp;&nbsp; tree_elem * curr = m_root;<br>&nbsp;&nbsp;&nbsp; while (curr &amp;&amp; curr-&gt;m_data != key)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curr-&gt;m_data &gt; key &amp;&amp; curr-&gt;m_left == NULL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr-&gt;m_left = new tree_elem(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++m_size;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curr-&gt;m_data &lt; key &amp;&amp; curr-&gt;m_right == NULL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr-&gt;m_right = new tree_elem(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++m_size;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curr-&gt;m_data &gt; key)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr = curr-&gt;m_left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr = curr-&gt;m_right;<br>&nbsp;&nbsp;&nbsp; }<br>}</div><h2>Удаление элемента из дерева</h2>
<p>Удаление элемента из дерева - наиболее сложный из методов. Сначала найдем элемент, который нужно удалить (указатель <span class="page_code_style">curr</span>), указатель <span class="page_code_style">parent</span> указывает на его предка.</p>
<p>Если у <span class="page_code_style">curr</span> нет левого поддерева (условие <span class="page_code_style">curr-&gt;m_left == NULL</span>), то вместо <span class="page_code_style">curr</span> можно подвесить его правое поддерево целиком, то есть элемент <span class="page_code_style">curr</span> удаляется, а на его место становится его правое поддерево <span class="page_code_style">curr-&gt;m_right</span>.</p>
<p>Аналогично, если у <span class="page_code_style">curr</span> нет правого поддерева, то вместо него можно подвесить целиком левое поддерево.</p>
<p>Самый сложный случай - если у <span class="page_code_style">curr</span> есть и левое, и правое поддерево. В этом случае на место элемента <span class="page_code_style">curr</span> поставим наименьший элемент, который больше него. Для этого нужно спуститься в правое поддерево элемента <span class="page_code_style">curr</span>, и в этом поддереве найти наименьший элемент - для этого будем двигаться указателем всегда в левого потомка текущего элемента, пока не найдем элемент, у которого нет левого потомка. Этот элемент можно удалить той же самой процедурой (т.к. у него нет левого потомка, то это простой случай удаления), а его значение записать на место элемента <span class="page_code_style">curr</span>.</p>
<div class="page_code_style">void binary_tree::erase(int key)<br>{<br>&nbsp;&nbsp;&nbsp; tree_elem * curr = m_root;<br>&nbsp;&nbsp;&nbsp; tree_elem * parent = NULL;<br>&nbsp;&nbsp;&nbsp; while (curr &amp;&amp; curr-&gt;m_data != key)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent = curr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curr-&gt;m_data &gt; key)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr = curr-&gt;m_left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr = curr-&gt;m_right;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; if (!curr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; if (curr-&gt;m_left == NULL)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Вместо curr подвешивается его правое поддерево<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (parent &amp;&amp; parent-&gt;m_left == curr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent-&gt;m_left = curr-&gt;m_right;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (parent &amp;&amp; parent-&gt;m_right == curr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent-&gt;m_right = curr-&gt;m_right;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --m_size;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete curr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; if (curr-&gt;m_right == NULL)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Вместо curr подвешивается его левое поддерево<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (parent &amp;&amp; parent-&gt;m_left == curr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent-&gt;m_left = curr-&gt;m_left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (parent &amp;&amp; parent-&gt;m_right == curr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent-&gt;m_right = curr-&gt;m_left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --m_size;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete curr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // У элемента есть два потомка, тогда на место элемента поставим<br>&nbsp;&nbsp;&nbsp; // наименьший элемент из его правого поддерева<br>&nbsp;&nbsp;&nbsp; tree_elem * replace = curr-&gt;m_right;<br>&nbsp;&nbsp;&nbsp; while (replace-&gt;m_left)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replace = replace-&gt;m_left;<br>&nbsp;&nbsp;&nbsp; int replace_value = replace-&gt;m_data;<br>&nbsp;&nbsp;&nbsp; erase(replace_value);<br>&nbsp;&nbsp;&nbsp; curr-&gt;m_data = replace_value;<br>}</div></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>