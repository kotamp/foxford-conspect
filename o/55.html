<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>23. Дерево отрезков</title></head><body><h1>23. Дерево отрезков</h1>
<div class="page_content_main"><h1>Дерево отрезков</h1>
<p>Дерево отрезков строится на массиве. Элемент дерева соответствует какому-то подотрезку массива <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>[</mo><mi>a</mi><mo>;</mo><mi>b</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.555ex" height="2.776ex" viewBox="0 -817.1 1961.2 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMAIN-5B" x="0" y="0"></use><use xlink:href="#MJMATHI-61" x="278" y="0"></use><use xlink:href="#MJMAIN-3B" x="808" y="0"></use><use xlink:href="#MJMATHI-62" x="1253" y="0"></use><use xlink:href="#MJMAIN-5D" x="1682" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><mi>a</mi><mo>;</mo><mi>b</mi><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-1">[a; b]</script>. При этом корень дерева соответствует всему отрезку <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>[</mo><mn>1</mn><mo>;</mo><mi>N</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.554ex" height="2.776ex" viewBox="0 -817.1 2391.2 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMAIN-5B" x="0" y="0"></use><use xlink:href="#MJMAIN-31" x="278" y="0"></use><use xlink:href="#MJMAIN-3B" x="779" y="0"></use><use xlink:href="#MJMATHI-4E" x="1224" y="0"></use><use xlink:href="#MJMAIN-5D" x="2112" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><mn>1</mn><mo>;</mo><mi>N</mi><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-2">[1; N]</script>.</p>
<p>Каждый отрезок разбивается на две равные (или отличающиеся по длине на 1) части. У вершины, соответствующей этому отрезку два потомка - левый и правый, соответствующий левому и правому отрезку разбиения. Отрезки длины 1 соответствуют отдельному элементу и являются листьями (у них нет потомков).</p>
<p>В каждой вершине хранится функция, для которой строится дерево отрезков (минимум, максимум, сумма).</p>
<p>Будем реализовывать дерево отрезков при помощи ссылочной реализации. Для представления одной вершины дерева будем использовать следующую структуру (пример для нахождения максимального значения на отрезке):</p>
<div class="page_code_style">
<p>struct node<br>{<br>&nbsp;&nbsp;&nbsp; int left, right, max;<br>&nbsp;&nbsp;&nbsp; node * child_left, * child_right;<br>};</p>
</div>
<p>Поля структуры:</p>
<p><span class="page_code_style">left</span> - значение индекса левого конца отрезка массива, которому соответствует данная вершина.</p>
<p><span class="page_code_style">right</span> - значение индекса правого конца отрезка массива, которому соответствует данная вершина.</p>
<p><span class="page_code_style">max</span> - значение наибольшего элемента массива на отрезке <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.368ex" height="2.776ex" viewBox="0 -817.1 4894.7 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMAIN-5B" x="0" y="0"></use><use xlink:href="#MJMATHI-6C" x="278" y="0"></use><use xlink:href="#MJMATHI-65" x="577" y="0"></use><use xlink:href="#MJMATHI-66" x="1043" y="0"></use><use xlink:href="#MJMATHI-74" x="1594" y="0"></use><use xlink:href="#MJMAIN-3B" x="1955" y="0"></use><use xlink:href="#MJMATHI-72" x="2400" y="0"></use><use xlink:href="#MJMATHI-69" x="2852" y="0"></use><use xlink:href="#MJMATHI-67" x="3197" y="0"></use><use xlink:href="#MJMATHI-68" x="3678" y="0"></use><use xlink:href="#MJMATHI-74" x="4254" y="0"></use><use xlink:href="#MJMAIN-5D" x="4616" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-3">[left; right]</script>.</p>
<p><span class="page_code_style">child_left</span> - ссылка на левого потомка.</p>
<p><span class="page_code_style">child_right</span> - ссылка на правого потомка.</p><h1>Построение дерева отрезков</h1>
<p>Дерево отрезков строится при помощи следующей рекурсивной функции:</p>
<div class="page_code_style">
<p>node* build(int left, int right, vector&lt;int&gt; &amp; values)<br>{<br>&nbsp;&nbsp;&nbsp; if (left &gt; right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>&nbsp;&nbsp;&nbsp; node * res = new node;<br>&nbsp;&nbsp;&nbsp; res-&gt;left = left;<br>&nbsp;&nbsp;&nbsp; res-&gt;right = right;<br>&nbsp;&nbsp;&nbsp; if (right == left)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res-&gt;child_left = res-&gt;child_right = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res-&gt;max = values[left];<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mid = (left + right) / 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res-&gt;child_left = build(left, mid, values);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res-&gt;child_right = build(mid + 1, right, values);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (res-&gt;child_left-&gt;max &gt;= res-&gt;child_right-&gt;max)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res-&gt;max = res-&gt;child_left-&gt;max;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res-&gt;max = res-&gt;child_right-&gt;max;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return res;<br>}</p>
</div>
<p>Эта функция строит дерево отрезков для подотрезка массива <span class="page_code_style">values</span> с концами <span class="page_code_style">left</span> и <span class="page_code_style">right</span>. Корень построенного дерева будет соответствовать всему подотрезку <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.368ex" height="2.776ex" viewBox="0 -817.1 4894.7 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMAIN-5B" x="0" y="0"></use><use xlink:href="#MJMATHI-6C" x="278" y="0"></use><use xlink:href="#MJMATHI-65" x="577" y="0"></use><use xlink:href="#MJMATHI-66" x="1043" y="0"></use><use xlink:href="#MJMATHI-74" x="1594" y="0"></use><use xlink:href="#MJMAIN-3B" x="1955" y="0"></use><use xlink:href="#MJMATHI-72" x="2400" y="0"></use><use xlink:href="#MJMATHI-69" x="2852" y="0"></use><use xlink:href="#MJMATHI-67" x="3197" y="0"></use><use xlink:href="#MJMATHI-68" x="3678" y="0"></use><use xlink:href="#MJMATHI-74" x="4254" y="0"></use><use xlink:href="#MJMAIN-5D" x="4616" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-4">[left; right]</script>. Функция возвращает указатель на корень построенного дерева.</p>
<p>Функция устроена так:</p>
<p>1. Если <span class="page_code_style">left &gt; right</span>, то это вырожденный случай (отрезок пустой) и функция возвращает нулевой указатель.</p>
<p>2. Если <span class="page_code_style">left == right</span>, то отрезок состоит из одного элемента, это - лист дерева, у него нет потомков. Поэтому указатели на левого и правого потомка инициализируются нулями, а в поле <span class="page_code_style">max</span> записывается значение элемента массива.</p>
<p>3. Иначе отрезок разбивается на две части и функция вызывается рекурсивно для построения дерева отрезков для левой и правой части. Поля <span class="page_code_style">child_left</span> и <span class="page_code_style">child_right</span> инициализируются значениями, которая вернули рекурсивные вызовы, а поле <span class="page_code_style">max</span> инициализируется максимумом из значений <span class="page_code_style">max</span> для левого и правого подотрезков.</p><h1>Запрос значения на подотрезке</h1>
<p>Рассмотрим функцию нахождения максимума на отрезке <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.368ex" height="2.776ex" viewBox="0 -817.1 4894.7 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMAIN-5B" x="0" y="0"></use><use xlink:href="#MJMATHI-6C" x="278" y="0"></use><use xlink:href="#MJMATHI-65" x="577" y="0"></use><use xlink:href="#MJMATHI-66" x="1043" y="0"></use><use xlink:href="#MJMATHI-74" x="1594" y="0"></use><use xlink:href="#MJMAIN-3B" x="1955" y="0"></use><use xlink:href="#MJMATHI-72" x="2400" y="0"></use><use xlink:href="#MJMATHI-69" x="2852" y="0"></use><use xlink:href="#MJMATHI-67" x="3197" y="0"></use><use xlink:href="#MJMATHI-68" x="3678" y="0"></use><use xlink:href="#MJMATHI-74" x="4254" y="0"></use><use xlink:href="#MJMAIN-5D" x="4616" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-5">[left; right]</script>. Точнее, данная функция находит максимум на пересечении отрезка <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.368ex" height="2.776ex" viewBox="0 -817.1 4894.7 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMAIN-5B" x="0" y="0"></use><use xlink:href="#MJMATHI-6C" x="278" y="0"></use><use xlink:href="#MJMATHI-65" x="577" y="0"></use><use xlink:href="#MJMATHI-66" x="1043" y="0"></use><use xlink:href="#MJMATHI-74" x="1594" y="0"></use><use xlink:href="#MJMAIN-3B" x="1955" y="0"></use><use xlink:href="#MJMATHI-72" x="2400" y="0"></use><use xlink:href="#MJMATHI-69" x="2852" y="0"></use><use xlink:href="#MJMATHI-67" x="3197" y="0"></use><use xlink:href="#MJMATHI-68" x="3678" y="0"></use><use xlink:href="#MJMATHI-74" x="4254" y="0"></use><use xlink:href="#MJMAIN-5D" x="4616" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-6">[left; right]</script>, который передается в качестве параметров функции, и того отрезка, которому соответствует корень дерева. Это необходимо для того, что в процессе рекурсивных вызовов отрезок, за который отвечает корень дерева, может уменьшатся, и может стать, например, подотрезком того отрезка, который задан в запросе.</p>
<div class="page_code_style">
<p>int query(node * root, int left, int right)<br>{<br>&nbsp;&nbsp;&nbsp; if (right &lt; root-&gt;left || left &gt; root-&gt;right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -INF;<br>&nbsp;&nbsp;&nbsp; if (left &lt;= root-&gt;left &amp;&amp; root-&gt;right &lt;= right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root-&gt;max;<br>&nbsp;&nbsp;&nbsp; int ans1 = query(root-&gt;child_left, left, right);<br>&nbsp;&nbsp;&nbsp; int ans2 = query(root-&gt;child_right, left, right);<br>&nbsp;&nbsp;&nbsp; return max(ans1, ans2);<br>}</p>
</div>
<p>Прежде всего функция проверяет, пересекается ли отрезок запроса с отрезком корня дерева. Если не пересекаются, то функция возвращает специальное значение (-INF для функции-максимума, INF для функции-минимума, 0 для суммы).</p>
<p>Затем проверяется условие вложенности отрезка корня дерева в отрезок запроса. Если условие верно, то запрос полностью покрывает ту вершину дерева, о которой идет речь, поэтому в качестве ответа на запрос можно вернуть поле <span class="page_code_style">max</span> данной вершины.</p>
<p>Иначе сделаем два рекурсивных вызова для левого и правого поддерева и выберем наибольшее из тех значений, которые они вернули.</p><h1>Обновление элемента дерева</h1>
<p>Обновление элемента дерева также производится рекурсивной функцией.</p>
<p>Параметры функции - индекс обновляемого элемента <span class="page_code_style">idx</span> и новое значение <span class="page_code_style">val</span>.</p>
<div class="page_code_style">void update(node * root, int idx, int val)<br>{<br>&nbsp;&nbsp;&nbsp; if (idx &lt; root-&gt;left || idx &gt; root-&gt;right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; if (root-&gt;left == root-&gt;right)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-&gt;min = root-&gt;max = val;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; update(root-&gt;child_left, idx, val);<br>&nbsp;&nbsp;&nbsp; update(root-&gt;child_right, idx, val);<br>&nbsp;&nbsp;&nbsp; root-&gt;max = max(root-&gt;child_left-&gt;max, root-&gt;child_right-&gt;max);<br>}</div>
<p>Функция устроена аналогично - если <span class="page_code_style">idx</span> не попадает внутрь отрезка дерева, функция ничего не делает. Если отрезок является листом, то функция обновляет поле <span class="page_code_style">max</span>, присваивая ему значение <span class="page_code_style">val</span>. Иначе функция вызывается для левого и правого поддерева (один из этих вызовов на самом деле сразу же завершится), после чего обновляет значение <span class="page_code_style">max</span> наибольшим из значением <span class="page_code_style">max</span> для поддеревьев.</p><h1>Групповое обновление с групповым запросом</h1>
<p>Рассмотрим дерево отрезков с групповой операций обновления: ко всем элементам подотрезка <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.368ex" height="2.776ex" viewBox="0 -817.1 4894.7 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMAIN-5B" x="0" y="0"></use><use xlink:href="#MJMATHI-6C" x="278" y="0"></use><use xlink:href="#MJMATHI-65" x="577" y="0"></use><use xlink:href="#MJMATHI-66" x="1043" y="0"></use><use xlink:href="#MJMATHI-74" x="1594" y="0"></use><use xlink:href="#MJMAIN-3B" x="1955" y="0"></use><use xlink:href="#MJMATHI-72" x="2400" y="0"></use><use xlink:href="#MJMATHI-69" x="2852" y="0"></use><use xlink:href="#MJMATHI-67" x="3197" y="0"></use><use xlink:href="#MJMATHI-68" x="3678" y="0"></use><use xlink:href="#MJMATHI-74" x="4254" y="0"></use><use xlink:href="#MJMAIN-5D" x="4616" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-7">[left; right]</script> прибавить одинаковое значение <span class="page_code_style">delta</span>.</p>
<p>Для эффективной реализации группового обновления необходимо в каждой вершине дерева отрезков хранить дополнительное поле <span class="page_code_style">add</span> - это величина, которая добавляется ко всем элементам на данном отрезке. Если запрос на обновление целиком покрывает какую-то вершину дерева, то просто изменяется величина <span class="page_code_style">add</span> в данной вершине, никакие другие значения не меняются.</p>
<p>Максимальным значением в данном поддереве тогда будет сумма полей <span class="page_code_style">max</span> и <span class="page_code_style">add</span>.</p>
<h3>Функция обновления значения на отрезке</h3>
<div class="page_code_style">void update(node * root, int left, int right, int delta)<br>{<br>&nbsp;&nbsp;&nbsp; if (right &lt; root-&gt;left || left &gt; root-&gt;right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; if (left &lt;= root-&gt;left &amp;&amp; right &gt;= root-&gt;right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-&gt;add += delta;<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update(root-&gt;child_left, left, right, delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update(root-&gt;child_right, left, right, delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-&gt;max = max(root-&gt;child_left-&gt;max + root-&gt;child_left-&gt;add,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-&gt;child_right-&gt;max + root-&gt;child_right-&gt;add);<br>&nbsp;&nbsp;&nbsp; }<br>}</div>
<h3>Функция запроса максимума на отрезке</h3>
<div class="page_code_style">int query(node * root, int left, int right)<br>{<br>&nbsp;&nbsp;&nbsp; if (right &lt; root-&gt;left || left &gt; root-&gt;right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -INF;<br>&nbsp;&nbsp;&nbsp; if (left &lt;= root-&gt;left &amp;&amp; right &gt;= root-&gt;right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root-&gt;add + root-&gt;max;<br>&nbsp;&nbsp;&nbsp; int ans1 = query(root-&gt;child_left, left, right);<br>&nbsp;&nbsp;&nbsp; int ans2 = query(root-&gt;child_right, left, right);<br>&nbsp;&nbsp;&nbsp; return root-&gt;add + max(ans1, ans2);<br>}</div>
<p>Функция работает следующим образом. Если отрезок запроса и отрезок вершины дерева не пересекаются, функция возвращает специальное значение -INF. Если отрезок вершины дерева целиком содержится в отрезке запроса, функция возвращает сумму полей <span class="page_code_style">add</span> и <span class="page_code_style">max</span>.</p>
<p>Иначе запрос разбивается на две части и спускается в левое и правое поддерево. Из значений, которое вернули рекурсивные вызовы из левого и правого поддерева берётся наибольшее. Функция возвращает это наибольшее, добавив значение <span class="page_code_style">add</span> из этой вершины.</p></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>