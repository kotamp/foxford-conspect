<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>25. Групповые операции в декартовом дереве</title></head><body><h1>25. Групповые операции в декартовом дереве</h1>
<div class="page_content_main"><h1>Групповые запросы в декартовом дереве</h1>
<p>Как и в дереве отрезков, можно реализовать групповые запросы в декартовом дереве (например, запрос суммы, максимума, минимума на подотрезке, то есть на наборе подряд идущих элементов). Часто групповые операции используются в декартовом дереве по неявному ключу.</p>
<p>Например, для того, чтобы отвечать на запрос о нахождении наибольшего значения будем хранить в каждой вершине значение максимума в данном поддереве. Для этого нужно модифицировать описание структуры <span class="page_code_style">node</span>:</p>
<div class="page_code_style">struct node<br>{<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>&nbsp;&nbsp;&nbsp; int max;<br>&nbsp;&nbsp;&nbsp; node * left;<br>&nbsp;&nbsp;&nbsp; node * right;<br><br>&nbsp;&nbsp;&nbsp; node(int val)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = val;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max = val;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = rand();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left = nullptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right = nullptr;<br>&nbsp;&nbsp;&nbsp; }<br>};</div>
<p>Напишем функцию, которая возвращает значение максимума в данном поддереве с проверкой на то, что указатель может быть и нулевым (в этом случае возвращается минус бесконечность):</p>
<div class="page_code_style">
<p>int get_max(node * root)<br>{<br>&nbsp;&nbsp;&nbsp; if (root)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root-&gt;max;<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -INF;<br>}</p>
</div>
<p>Напишем также функцию, которая обновляет значение поля max в вершине.</p>
<div class="page_code_style">
<p>void update(node * root)<br>{<br>&nbsp;&nbsp;&nbsp; if (root == nullptr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; root-&gt;max = max(x, max(get_max(root-&gt;left), get_max(root-&gt;right)));<br>}</p>
</div>
<p>Эту функцию необходимо вызывать при каждой операцией с вершиной декартова дерева, например, при каждом вызове операции <span class="page_code_style">split</span>.</p>
<div class="page_code_style">pair &lt;node *, node *&gt; split(node * root, int val)<br>{<br>&nbsp;&nbsp;&nbsp; if (root == nullptr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {nullptr, nullptr};<br>&nbsp;&nbsp;&nbsp; if (root-&gt;x &lt;= val)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto res = split(root-&gt;right, val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-&gt;right = res.first;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update_max(root);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {root, res.second};<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto res = split(root-&gt;left, val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-&gt;left = res.second;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update_max(root);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {res.first, root};<br>&nbsp;&nbsp;&nbsp; }<br>}</div>
<p>И при операции <span class="page_code_style">merge</span>L</p>
<div class="page_code_style">
<p>node * merge(node * root1, node * root2)<br>{<br>&nbsp;&nbsp;&nbsp; if (root1 == nullptr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root2;<br>&nbsp;&nbsp;&nbsp; else if (root2 == nullptr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root1;<br>&nbsp;&nbsp;&nbsp; if (root1-&gt;y &lt; root2-&gt;y)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root1-&gt;right = merge(root1-&gt;right, root2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update_max(root1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root1;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root2-&gt;left = merge(root1, root2-&gt;left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update_max(root2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root2;<br>&nbsp;&nbsp;&nbsp; }<br>}</p>
</div>
<p>Запрос значения максимума на отрезке удобно также делать при помощи операций <span class="page_code_style">split</span> и <span class="page_code_style">merge</span>: сначала разобьем дерево на три части так, чтобы интересующее нас дерево было отдельной частью, тогда для ответа на запрос достаточно вызвать функцию <span class="page_code_style">get_max</span> от корня дерева, после чего вызвать операции <span class="page_code_style">merge</span>.</p><h1>Групповое обновление в декартовом дереве</h1>
<p>Групповое обновление в декартовом дереве можно сделать, если в каждой вершине хранить дополнительное поле - значение групповой операции. Например, пусть необходимо реализовать групповую операцию - добавление ко всем элементам одной и той же величины. Добавим в структуру <span class="page_code_style">node</span> новое поле <span class="page_code_style">add</span> - значение групповой добавки ко всем вершинам поддерева с данным корнем. Теперь функция <span class="page_code_style">get_max</span> будет вычисляться так:</p>
<div class="page_code_style">
<p>int get_max(node * root)<br>{<br>&nbsp;&nbsp;&nbsp; if (root)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root-&gt;max + root-&gt;add;<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -INF;<br>}</p>
</div>
<p>Однако, здесь возникают проблемы - при операциях split и merge происходит разделение разделение или объединение деревьев, поэтом необходимо изменять значение этой групповой добавки. Для этого необходимо реализовать функцию push, которая "снимает" значение групповой операции в вершине, "проталкивая" его в потомки — добавка спускается из этой вершины в потомки этой вершины:</p>
<div class="page_code_style">
<p>void push(node * root)<br>{<br>&nbsp;&nbsp;&nbsp; if (root == nullptr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; if (root-&gt;left)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-&gt;left-&gt;add += root-&gt;add;<br>&nbsp;&nbsp;&nbsp; if (root-&gt;right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-&gt;right-&gt;add += root-&gt;add;<br>&nbsp;&nbsp;&nbsp; root-&gt;max += root-&gt;add;<br>&nbsp;&nbsp;&nbsp; root-&gt;add = 0;<br>}</p>
</div>
<p>Эту операцию нужно вызывать при каждом вызове операций&nbsp; <span class="page_code_style">split</span>.</p>
<div class="page_code_style">pair &lt;node *, node *&gt; split(node * root, int val)<br>{<br>&nbsp;&nbsp;&nbsp; if (root == nullptr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {nullptr, nullptr};<br><strong>&nbsp;&nbsp;&nbsp; push(root);</strong><br>&nbsp;&nbsp;&nbsp; if (root-&gt;x &lt;= val)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto res = split(root-&gt;right, val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-&gt;right = res.first;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update_max(root);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {root, res.second};<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto res = split(root-&gt;left, val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-&gt;left = res.second;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update_max(root);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {res.first, root};<br>&nbsp;&nbsp;&nbsp; }<br>}</div>
<p>И при операции <span class="page_code_style">merge</span>:</p>
<div class="page_code_style">
<p>node * merge(node * root1, node * root2)<br>{<br>&nbsp;&nbsp;&nbsp; if (root1 == nullptr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root2;<br>&nbsp;&nbsp;&nbsp; else if (root2 == nullptr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root1;<br>&nbsp;&nbsp;&nbsp; if (root1-&gt;y &lt; root2-&gt;y)<br>&nbsp;&nbsp;&nbsp; {<br><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; push(root1);</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root1-&gt;right = merge(root1-&gt;right, root2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update_max(root1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root1;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; push(root2);</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root2-&gt;left = merge(root1, root2-&gt;left);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update_max(root2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root2;<br>&nbsp;&nbsp;&nbsp; }<br>}</p>
</div>
<p>Для группового обновления необходимо также разбить декартово дерево на части и в одной части установить значение поля <span class="page_code_style">add</span>, после чего объединить части вместе.</p></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>