<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>8. Ассоциативный контейнер map STL</title></head><body><h1>8. Ассоциативный контейнер map STL</h1>
<div class="page_content_main"><p>Обычные массивы представляют собой набор пронумерованных элементов, то есть для обращения к какому-либо элементу списка необходимо указать его номер. Номер элемента в списке однозначно идентифицирует сам элемент. Но идентифицировать данные по числовым номерам не всегда оказывается удобно. Например, маршруты поездов в России идентифицируются численно-буквенным кодом (число и одна цифра), также численно-буквенным кодом идентифицируются авиарейсы, то есть для хранения информации о рейсах поездов или самолетов в качестве идентификатора удобно было бы использовать не число, а текстовую строку.</p>
<p>Структура данных, позволяющая идентифицировать ее элементы не по числовому индексу, а по произвольному, называется <em>словарем</em> или <em>ассоциативным массивом</em>. Соответствующая структура данных в библиотеке STL называется <code></code><span class="page_code_style"><code>map</code></span> (отображение), поскольку словарь является сопоставлением элементам одного множества (ключам, то есть индексам) значения из другого множества. Для использования этой структуры необходимо подключить заголовочный файл <code></code><span class="page_code_style"><code>map</code></span>.</p>
<p>Рассмотрим простой пример использования словаря. Заведем словарь <code></code><span class="page_code_style"><code>Capitals</code></span>, где индексом является название страны, а значением&nbsp;— название столицы этой страны. Это позволит легко определять по строке с названием страны ее столицу.</p>
<div class="page_code_style">
<pre>// Создадим словарь
map &lt;string, string&gt; Capitals;

// Заполним его несколькими значениями
Capitals["Russia"] = "Moscow";
Capitals["Ukraine"] = "Kiev";
Capitals["USA"] = "Washington";

cout &lt;&lt; "В какой стране вы живете? ";
cin &gt;&gt; country;

// Проверим, есть ли такая страна в словаре Capitals
if (Capitals.count(country))
{
    // Если есть - выведем ее столицу
    cout &lt;&lt; "Столица вашей страны " &lt;&lt; Capitals[country] &lt;&lt; endl;
}
else
{
    // Запросим название столицы и добавив его в словарь
    cout &lt;&lt; "Как называется столица вашей страны? ";
    cin &gt;&gt; city;
    Capitals[country] = city;
}
</pre>
</div>
<p>Итак, каждый элемент словаря состоит из двух объектов: <em>ключа</em> и <em>значения</em>. В нашем примере ключом является название страны, значением является название столицы. Ключ идентифицирует элемент словаря, значение является данными, которые соответствуют данному ключу. Значения ключей&nbsp;— уникальны, двух одинаковых ключей в словаре быть не может.</p>
<p>При объявлении структуры данных из шаблона <code></code><span class="page_code_style"><code>map</code></span> необходимо указать типы данных ключа и значения. В нашем примере оба этих типа <code></code><span class="page_code_style"><code>string</code></span>.</p>
<p>В жизни широко распространены словари, например, привычные бумажные словари (толковые, орфографические, лингвистические). В них ключом является слово-заголовок статьи, а значением&nbsp;— сама статья. Для того, чтобы получить доступ к статье, необходимо указать слово-ключ.</p>
<p>Другой пример словаря, как структуры данных&nbsp;— телефонный справочник. В нем ключом является имя, а значением&nbsp;— номер телефона. И словарь, и телефонный справочник хранятся так, что легко найти элемент словаря по известному ключу (например, если записи хранятся в алфавитном порядке ключей, то легко можно найти известный ключ, например, бинарным поиском), но если ключ неизвестен, а известно лишь значение, то поиск элемента с данным значением может потребовать последовательного просмотра всех элементов словаря.</p>
<p>Особенностью ассоциативного массива является его динамичность: в него можно добавлять новые элементы с произвольными ключами и удалять уже существующие элементы. При этом размер используемой памяти пропорционален размеру ассоциативного массива. Доступ к элементам ассоциативного массива выполняется хоть и медленнее, чем к обычным массивам, но в целом довольно быстро.</p>
<h2>Когда нужно использовать словари</h2>
<p>Словари нужно использовать в следующих случаях:</p>
<ul>
<li>Подсчет числа каких-то объектов. В этом случае нужно завести словарь, в котором ключами являются объекты, а значениями&nbsp;— их количество.</li>
<li>Хранение каких-либо данных, связанных с объектом. Ключи&nbsp;— объекты, значения&nbsp;— связанные с ними данные. Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря <code><span class="page_code_style">Num["January"] = 1;</span> <span class="page_code_style">Num["February"] = 2;</span> …</code>.</li>
<li>Установка соответствия между объектами (например, “родитель—потомок”). Ключ&nbsp;— объект, значение&nbsp;— соответствующий ему объект.</li>
<li>Если нужен обычный массив, но при этом максимальное значение индекса элемента очень велико, но при этом будут использоваться не все возможные индексы (так называемый “разреженный массив”), то можно использовать ассоциативный массив для экономии памяти.</li>
</ul>
<h2>Работа с элементами словаря</h2>
<p>Основная операция со словарем: получение значения элемента по ключу, записывается так же, как и для массивов: <code><span class="page_code_style">A[key]</span></code>. Если элемента с заданным ключом не существует в словаре, то возвращается 0, если значения словаря&nbsp; числовые, пустая строка для строковых значений и значение, возвращаемое конструктором по умолчанию для более сложных объектов. Также для доступа к элементам словаря можно использовать метод <span class="page_code_style">at(key)</span>. Как и в случае с вектором, этот метод производит проверку наличия в словаре элемента с ключом <span class="page_code_style">key</span>, а при его отсутствии генерирует исключение (ошибка исполнения). Проверить принадлежность ключа <code></code><span class="page_code_style"><code>key</code></span> словарю можно методами <code><span class="page_code_style">count(key)</span></code> (возвращает количество вхождений ключа в словать, то есть 0 или 1) или <code><span class="page_code_style">find(key)</span></code> (возвращает итератор на найденный элемент или значение <code><span class="page_code_style">end()</span></code>, если элемент отcутствует в словаре). Для добавления нового элемента в словарь нужно просто присвоить ему какое-то значение: <code><span class="page_code_style">A[key] = value</span></code>. Операции доступа к элементу по его ключу и добавления элемента в словарь производятся за <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>log</mi><mo>&amp;#x2061;</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.336ex" height="2.776ex" viewBox="0 -817.1 3589.2 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="#MJMAIN-6C"></use><use xlink:href="#MJMAIN-6F" x="278" y="0"></use><use xlink:href="#MJMAIN-67" x="779" y="0"></use></g><use xlink:href="#MJMATHI-6E" x="2599" y="0"></use><use xlink:href="#MJMAIN-29" x="3199" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-13">O(\log n)</script> (<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.611ex" viewBox="0 -566.3 600.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-14">n</script>&nbsp;— число элементов в словаре). Для удаления элемента из словаря используется метод <code></code><span class="page_code_style"><code>erase()</code></span>. В качестве параметра ему нужно передать либо значение ключа удаляемого элемента (тогда удаление производится за <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-15-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>log</mi><mo>&amp;#x2061;</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.336ex" height="2.776ex" viewBox="0 -817.1 3589.2 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="#MJMAIN-6C"></use><use xlink:href="#MJMAIN-6F" x="278" y="0"></use><use xlink:href="#MJMAIN-67" x="779" y="0"></use></g><use xlink:href="#MJMATHI-6E" x="2599" y="0"></use><use xlink:href="#MJMAIN-29" x="3199" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-15">O(\log n)</script>), либо итератор на удаляемый элемент (тогда удаление будет проводиться за <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-16-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.776ex" viewBox="0 -817.1 2043 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><use xlink:href="#MJMAIN-31" x="1153" y="0"></use><use xlink:href="#MJMAIN-29" x="1653" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-16">O(1)</script>).</p><h2>Перебор элементов словаря</h2>
<p>Как и для множеств, для словарей определены итераторы. Методы <code></code><span class="page_code_style"><code>find</code></span>, <code></code><span class="page_code_style"><code>upper_bound</code></span>, <code></code><span class="page_code_style"><code>lower_bound</code></span>, <code><span class="page_code_style">begin</span></code>, <code></code><span class="page_code_style"><code>end</code></span>, <code></code><span class="page_code_style"><code>rbegin</code></span>, <code></code><span class="page_code_style"><code>rend</code></span> возвращают итератор на элемент словаря. Назначение этих элементов такое же, как для контейнера set. Методы поиска в качестве параметра получают ключ элемента.</p>
<p>Разыменование итератора возвращает объект типа <code></code><span class="page_code_style"><code>pair</code></span>, у которого поле <code></code><span class="page_code_style"><code>first</code></span>&nbsp;— это ключ элемента, а поле <code></code><span class="page_code_style"><code>second</code></span>&nbsp;— его значение.</p>
<p>Используя итераторы можно организовать перебор всех элементов словаря:</p>
<div class="page_code_style">for (auto it = Capitals.begin(); it != Capitals.end(); ++it) {<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Страна: " &lt;&lt; (*it).first &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Столица: " &lt;&lt; (*it).second &lt;&lt; endl;<br>}</div>
<p>Вместо громоздкой записи <code></code><span class="page_code_style"><code>(*it).first</code></span> и <code></code><span class="page_code_style"><code>(*it).second</code></span> можно использовать более компактный оператор доступа к полю через указатель “<code>-&gt;</code>”: <code><span class="page_code_style">it-&gt;first</span></code>, <code></code><span class="page_code_style"><code>it-&gt;second</code></span>.</p>
<p>Также элементы словаря можно перебирать и при помощи range-based циклов. В этом случае значение элемента словаря - это пара из двух полей: ключ и значение. Аналогичный пример вывода элементов словаря, разыменовывать auto-переменную не нужно:</p>
<div class="page_code_style">for (auto elem: Capitals) {<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Страна: " &lt;&lt; elem.first &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Столица: " &lt;&lt; elem.second &lt;&lt; endl;<br>}</div>
</div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>