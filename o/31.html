<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>10. Правильные скобочные последовательности. Проверка на правильность.</title></head><body><h1>10. Правильные скобочные последовательности. Проверка на правильность.</h1>
<div class="page_content_main"><h1>Определение правильной скобочной последовательности</h1>
<p>Одним из применений стека является алгоритм проверки правильности скобочной последовательности. Рассмотрим какое-либо выражение, в котором могут встречаться скобки трех видов — круглые «(» и «)», квадратные «[» и «]» и фигурные «{» и «}». Теперь уберем все символы, кроме скобок. Полученную последовательность будем называть «правильной скобочной последовательностью».</p>
<p>Например, последовательность «([])» будет правильной, а последовательность «([)]» - нет (нарушен порядок вложенности скобок.</p>
<p>Более формальное определение правильной скобочной последовательности строится индуктивно. Прежде всего, пустая строка — это правильная скобочная последовательность. Если A — правильная скобочная последовательность, то «(A)», «[A]» и «{A}» также являются правильными скобочными последовательностями. Наконец, если A и B — правильные скобочные последовательности, то их конкатенация AB также будет правильной скобочной последовательностью.</p><h1>Проверка скобочной последовательности на правильность</h1>
<p>Это определение позволяет сформулировать алгоритм проверки скобочной последовательности на правильность. Найдем в последовательности пару подряд идущих парных скобок — например, «()». Удалим эту пару из последовательности. Будем продолжать так пока есть такая пара. Если в результата получилась пустая строка, то исходная последовательность была правильной.</p>
<p>Но поскольку удаление подстроки из середины строки выполняется за линейное время, то такой алгоритм будет иметь сложность <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.032ex" height="3.068ex" viewBox="0 -942.5 2596.9 1320.7" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="#MJMAIN-32" x="849" y="513"></use></g><use xlink:href="#MJMAIN-29" x="2207" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1">O(n^2)</script>.</p>
<p>Использование стека позволяет улучшить этот алгоритм — встреченная закрывающая скобка должна быть парной к последней встреченной открывающей, после чего их необходимо удалить. Для хранения открывающих скобок будем использовать стек. Пройдем по строке от начала до конца. Если очередной символ — открывающая скобка, то добавляем ее в стек. Если закрывающая — то проверяем, что стек не пуст и скобка на вершине стека парная к данной закрывающей. При соблюдении условий открывающая скобка удаляется из стека, иначе алгоритм заканчивает свою работу (последовательность неправильная).</p>
<p>После окончания работы алгоритма стек должен остаться пустым. Если стек не пуст — это означает, что некоторые открывающие скобки не были закрыты, то есть последовательность не является правильной.</p><h1>Проверка на правильность последовательности одного вида скобок</h1>
<p>Если последовательность состоит из одного вида скобок, то алгоритм можно упростить так, чтобы он использовать <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.776ex" viewBox="0 -817.1 2043 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><use xlink:href="#MJMAIN-31" x="1153" y="0"></use><use xlink:href="#MJMAIN-29" x="1653" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-2">O(1)</script> дополнительной памяти, поскольку в стеке будут храниться только открывающие скобки одного вида. В этом случае достаточно только запоминать размер стека, то есть число открывшихся скобок.</p>
<p>Назовем эту величину <em><strong>балансом</strong></em>. Будем рассматривать скобки по одной с начала скобочной последовательности. Открывающая скобка увеличивает значение баланса на 1, закрывающая — уменьшает. Последовательность будет правильной, если:</p>
<ol>
<li>Величина баланса всегда неотрицательна (во все промежуточные моменты).</li>
<li>Баланс всей скобочной последовательности равен 0.</li>
</ol></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>