<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>16. Алгоритм поиска в ширину</title></head><body><h1>16. Алгоритм поиска в ширину</h1>
<div class="page_content_main"><p><strong>Алгоритм поиска в ширину</strong> (англ. breadth-first search, BFS) позволяет найти кратчайшие пути из одной вершины невзвешенного (ориентированного или неориентированного) графа до всех остальных вершин. Под кратчайшим путем подразумевается путь, содержащий наименьшее число ребер.</p>
<p>Алгоритм построен на простой идее — пусть до какой-то вершины u найдено кратчайшее расстояние и оно равно d, а до вершины v кратчайшее расстояние не меньше, чем d. Тогда если вершины u и v – смежны, то кратчайшее расстояние до вершины v равно d+1.</p>
<p>Через d[i] будем обозначать кратчайшее расстояние до вершины i. Пусть начальная вершина имеет номер s, тогда d[s]=0. Для всех вершин смежных с s расстояние равно 1, для вершин, смежных с теми, до которых расстояние равно 1, расстояние равно 2 (если только оно не равно 0 или 1) и т. д.</p>
<p>Таким образом, организовать процесс вычисления кратчайших расстояний до вершин можно следующим образом. Для каждой вершины в массиве d будем хранить кратчайшее расстояние до этой вершины, если же расстояние неизвестно — будем хранить значение&nbsp; -1 или None (в языке Python). В самом начале расстояние до всех вершин равно -1 (None), кроме начальной вершины, до которой расстояние равно 0. Затем перебираем все вершины, до которых расстояние равно 0, перебираем смежные с ними вершины и для них записываем расстояние равное 1. Затем перебираем все вершины, до которых расстояние равно 1, перебираем их соседей, записываем для них расстояние, равное 2 (если оно до этого было равно -1 (None)). Затем перебираем вершины, до которых расстояние было равно 2 и тем самым определяем вершины, до которых расстояние равно 3 и т. д. Этот цикл можно повторять либо пока обнаруживаются новые вершины на очередном шаге, либо n−1 раз (где n – число вершин в графе), так как длина кратчайшего пути в графе не может превосходить n−1.</p>
<p>Такая реализация алгоритма будет неэффективной, если на каждом шаге перебирать все вершины, отбирая те, которые были обнаружены на последнем шаге. Для эффективной реализации следует использовать очередь.</p>
<p>В очередь будут закладываться вершины после того, как до них будет определено кратчайшее расстояние. То есть очередь будет содержать вершины, которые были «обнаружены» алгоритмом, но не были рассмотрены исходящие ребра из этих вершин. Можно также сказать, что это очередь на «обработку» вершин.</p>
<p>Из очереди последовательно извлекаются вершины, рассматриваются все исходящие из них ребра. Если ребро ведет в не обнаруженную до этого вершину, то есть расстояние до новой вершины не определено, то оно устанавливается равным на единицу больше, чем расстояние до обрабатываемой вершины, а новая вершина добавляется в конец очереди.</p>
<p>Таким образом, если из очереди извлечена вершина с расстоянием d, то в конец очереди будут добавляться вершины с расстоянием d+1, то есть в любой момент исполнения алгоритма очередь состоит из вершин, удаленных на расстояние d, за которыми следуют вершины, удаленные на расстояние d+1.</p>
<p>Запишем алгоритм поиска в ширину.</p>
<h3>Реализация на языке C++</h3>
<div class="page_code_style">vector&lt;int&gt; D(n + 1, -1);<br>D[start] = 0;<br>queue&lt;int&gt; Q;<br>Q.push(s);<br>while (!Q.empty())<br>{<br>&nbsp;&nbsp;&nbsp; int u = Q.front();<br>&nbsp;&nbsp;&nbsp; Q.pop();<br>&nbsp;&nbsp;&nbsp; for (auto v : V[u])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (D[v] == -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D[v] = D[u] + 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q.push(v);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>}</div>
<h3>Реализация на языке Python</h3>
<div class="page_code_style">
<p>D = [None] * (n + 1)<br> D[start] = 0<br> Q = [start]<br> Qstart = 0<br> while Qstart &lt; len(Q):<br>&nbsp; &nbsp; u = Q[Qstart]<br>&nbsp; &nbsp; Qstart += 1 <br>&nbsp; &nbsp; for v in V[u]: <br>&nbsp; &nbsp; &nbsp; &nbsp; if D[v] is None: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D[v] = D[u] + 1 <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Q.append(v)</p>
</div>
<p>В этом алгоритме n — число вершин в графе, пронумерованных от 1 до n. Номер начальной вершины (от которой ищутся пути) хранится в переменной start. Q — очередь, в которой хранятся обрабатываемые элементы (в примере на языке Python используйется список, Qstart — первый элемент очереди, добавление новой вершины в конец очереди — это вызов метода append для списка, удаление вершины из начала очереди — это увеличение Qstart на 1 (при этом первый элемент в очереди хранится в Q[Qstart])).</p>
<p>В самом начале в очередь добавляется только один элемент start, для которого в самом начале определено расстояние D[start] = 0 (для всех остальных элементов расстояние не определено). Цикл продолжается пока очередь не пуста (что в примере на Python проверяется условием Qstart &lt; len(Q)). В цикле из очереди удаляется первый элемент u. Затем перебираются все смежные с ним вершины v. Если вершина v не была обнаружена ранее, что проверяется при помощи условия D[v] == -1 (D[v] is None в Python), то расстояние до вершины v устанавливается равным расстоянию до вершины u, увеличенному на 1, затем вершина v добавляется в конец очереди.</p>
<p>Если в графе содержится n вершин и m ребер, то сложность такого алгоритма равна <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-28-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.858ex" height="2.776ex" viewBox="0 -817.1 4244.4 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><use xlink:href="#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="#MJMAIN-2B" x="1975" y="0"></use><use xlink:href="#MJMATHI-6D" x="2976" y="0"></use><use xlink:href="#MJMAIN-29" x="3854" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-28">O(n+m)</script>, так как алгоритму необходимо пройти по всем ребрам. Если граф хранится при помощи матрицы смежности, то сложность алгоритма равна <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-29-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.032ex" height="3.068ex" viewBox="0 -942.5 2596.9 1320.7" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="#MJMAIN-32" x="849" y="513"></use></g><use xlink:href="#MJMAIN-29" x="2207" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-29">O(n^2)</script>, так как внутренний цикл перебора всех смежных вершин будет содержать n шагов для каждой обработанной вершины графа.</p>
<h3>Реализация на языке Pascal</h3>
<div class="page_code_style">
<p>var<br> &nbsp; Q, D: array[1..1001] of longint;<br> &nbsp; a: array[1..1000, 1..1000] of longint;<br> &nbsp; i, j, n, start, finish, Qstart, Qend, u, v: longint;<br> begin<br> &nbsp; {считываем исходные данные:<br> &nbsp; количество вершин графа,<br> &nbsp; матрицу смежности,<br> &nbsp; номера стартовой и конечной вершины}<br> &nbsp; readln(n);<br> &nbsp; for i := 1 to n do<br> &nbsp; &nbsp; for j := 1 to n do<br> &nbsp; &nbsp; &nbsp; read(a[i, j]);<br> &nbsp; readln(start, finish); &nbsp; &nbsp;<br> &nbsp; {заполняем массив длин D}<br> &nbsp; for i := 1 to n do<br> &nbsp; &nbsp; D[i] := -1;<br> &nbsp; {расстояние от старта до старта равно нулю} &nbsp;<br> &nbsp; D[start] := 0;<br> &nbsp; {кладем стартовую вершину в очередь.<br> &nbsp; В очереди Q индекс Qstart - номер первого элемента очереди, Qend - номер ячейки после последнего элемента}<br> &nbsp; Q[1] := start;<br> &nbsp; Qstart := 1;<br> &nbsp; Qend := 2;<br> &nbsp; {Пока очередь не пуста, то есть, там есть хотя бы один элемент, то есть Qstart и Qend отличаются хотя бы на 1}<br> &nbsp; while Qstart &lt; Qend do&nbsp;<br> &nbsp; begin<br> &nbsp; &nbsp; u := Q[Qstart];//забираем первую вершину из очереди<br> &nbsp; &nbsp; inc(Qstart); //передвигаем индекс первого элемента очереди<br> &nbsp; &nbsp; {перебираем все вершины графа}<br> &nbsp; &nbsp; for v := 1 to n do&nbsp;<br> &nbsp; &nbsp; &nbsp; {если нашли соседа, у которого расстояние еще не вычислено}<br> &nbsp; &nbsp; &nbsp; if (a[u, v] = 1) and (d[v] = -1) then begin{вычисляем его и кладем этого соседа в очередь}<br> &nbsp; &nbsp; &nbsp; &nbsp; d[v] := d[u] + 1;<br> &nbsp; &nbsp; &nbsp; &nbsp; Q[Qend] := v;<br> &nbsp; &nbsp; &nbsp; &nbsp; inc(Qend);<br> &nbsp; &nbsp; &nbsp; end;<br> &nbsp; end;<br> &nbsp; writeln(d[finish]);<br> end.</p>
</div>
<p>Записанный алгоритм находит только кратчайшие расстояния до каждой из вершин графа. Чтобы найти кратчайший путь необходимо для каждой вершины хранить все ребра, по которым совершалось открытие новых вершин, то есть для каждой вершины необходимо хранить номер её предшественника — вершины, из которой была открыта данная вершина. Все сохраненные ребра вместе образуют дерево кратчайших путей. Чтобы построить кратчайший путь из начальной вершины до какой-то другой достижимой из нее вершины, необходимо взять путь в этом дереве, соединяющий эти две вершины.</p>
<h3>Реализация на языке C++</h3>
<p>Предшественников будем хранить в векторе:</p>
<div class="page_code_style">
<p>vector &lt;int&gt; prev(n + 1, -1);</p>
</div>
<p>Значение prev[i] есть номер предшествующей вершине i кратчайшего пути из вершины start. То есть чтобы построить кратчайший путь до вершины i необходимо построить кратчайший путь до вершины prev[i], а затем добавить к нему ребро из prev[i] в i.</p>
<p>При обнаружении новой вершины v в записанном алгоритме необходимо пометить, что данная вершина была достигнута проходом по ребру из вершины u, то есть предшественником вершины v является вершина u:</p>
<div class="page_code_style">
<p>prev[v] = u;</p>
</div>
<p>Для восстановления ответа (кратчайшего пути от вершины start до некоторой вершины finish) заведем вектор ans для сохранения ответа, затем будет последовательно переходить от каждой вершины к ее предшественнику, пока не дойдем до значения -1, то есть отсутствия предшественника:</p>
<div class="page_code_style">
<p>vector &lt;int&gt; ans;<br>int curr = finish;<br> while (curr != -1)<br>{<br>&nbsp; &nbsp; ans.push_back(curr);<br>&nbsp; &nbsp; curr = prev[curr];<br>}</p>
</div>
<p>В итоге вектор ans будет хранить вершины на кратчайшем пути от start до finish, записанные в обратном порядке.</p>
<h3>Реализация на языке Python</h3>
<p>Предшественников будем хранить в списке:</p>
<div class="page_code_style">
<p>Prev = [None] * (n + 1)</p>
</div>
<p>Значение Prev[i] есть номер предшествующей вершине i кратчайшего пути из вершины start. То есть чтобы построить кратчайший путь до вершины i необходимо построить кратчайший путь до вершины Prev[i], а затем добавить к нему ребро из Prev[i] в i.</p>
<p>При обнаружении новой вершины v в записанном алгоритме необходимо пометить, что данная вершина была достигнута проходом по ребру из вершины u, то есть предшественником вершины v является вершина u:</p>
<div class="page_code_style">
<p>Prev[v] = u</p>
</div>
<p>Для восстановления ответа (кратчайшего пути от вершины start до некоторой вершины finish) заведем список Ans для сохранения ответа, затем будет последовательно переходить от каждой вершины к ее предшественнику, пока не дойдем до значения None, то есть отсутствия предшественника:</p>
<div class="page_code_style">
<p>Ans = []<br> curr = finish<br> while curr is not None:<br>&nbsp; &nbsp; Ans.append(curr)<br>&nbsp; &nbsp; curr = Prev[curr]</p>
</div>
<p>В итоге список Ans будет хранить вершины на кратчайшем пути от start до finish, записанные в обратном порядке.</p>
<h3>Реализация на языке Pascal</h3>
<div class="page_code_style">
<p>…<br> for i := 1 to n do&nbsp;<br> &nbsp; begin<br> &nbsp; &nbsp; D[i] := -1;<br> &nbsp; &nbsp; Prev[i] := -1;<br> &nbsp; end; &nbsp;<br> …<br> Prev[v] := u;<br> …<br> tmp := finish;<br> &nbsp; i := 1;<br> &nbsp; while tmp &lt;&gt; -1 do&nbsp;<br> &nbsp; begin<br> &nbsp; &nbsp; ans[i] := tmp;<br> &nbsp; &nbsp; inc(i);<br> &nbsp; &nbsp; tmp := Prev[tmp];<br> &nbsp; end;<br> &nbsp; for j := i - 1 downto 1 do<br> &nbsp; &nbsp; write(ans[j], ' ');</p>
</div></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>