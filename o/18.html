<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>5. Контейнер vector в STL</title></head><body><h1>5. Контейнер vector в STL</h1>
<div class="page_content_main"><h2>Объявление вектора</h2>
<p>Вектор в STL - это аналог массива, контейнер, который позволяет осуществлять доступ к элементам по индексам. Вектор является шаблоном, и объявляется, как все остальные шаблоны.</p>
<p>Например, вектор целых чисел можно объявить так:</p>
<div class="page_code_style">
<p>vector &lt;int&gt; A;</p>
</div>
<p>При таком создании вектор является "пустым", не содержащим элементов. Можно сразу же объявить вектор некоторого фиксированного размера, если задать конструктор, указав в конструкторе количество элементов вектора:</p>
<div class="page_code_style">
<p>vector &lt;int&gt; A(n);</p>
</div>
<p>В этом случае значения элементов вектора будут нулевыми (а если элементами вектора являются не числа, а, например, строки или другие структуры данных, то элементы вектора будут принимать значения по умолчанию, то есть строки и вложенные вектора будут пустыми). При необходимости можно сразу же заполнить вектор некоторыми (одинаковыми), значениями, указав их в качестве второго параметра конструктора, например, для заполнения вектора значениями -1 можно его объявить так:</p>
<div class="page_code_style">
<p>vector&lt;int&gt; A(n, -1);</p>
</div>
<p>Для использования контейнера vector необходимо подключить заголовочный файл vector:</p>
<div class="page_code_style">
<p>#include&lt;vector&gt;</p>
</div><h2>Обращение к элементам вектора</h2>
<p>К элементам вектора можно обращаться по индексу, например, так: <span class="page_code_style">A[i]</span>.</p>
<p>Есть и другой способ обращения к элементу вектора с индексом i: использование метода at: <span class="page_code_style">A.at(i)</span>. Отличие метода at от обращения при помощи квадратных скобок в том, что при использовании метода at происходит проверка правильности индекса, и в случае выхода за границы вектора происходит ошибка исполнения. Это полезно при отладке программ.</p>
<p>При обращении к элементам вектора при помощи квадратных скобок корректность индекса не проверяется, и в случае выхода за границы вектора дальнейшее поведение программы может быть непредсказуемым.</p>
<p>Следует отметить, что работа с элементами вектора осуществляется медленнее, чем с элементами массива (даже при использовании квадратных скобок, то есть без проверки выхода за границы массива).</p>
<p>Помимо этого у вектора есть метод front(), возвращающий ссылку на первый элемент и метод back(), возвращающий ссылку на последний элемент вектора.</p><h2>Изменение размера вектора</h2>
<p>Размер вектора можно узнать при помощи универсального метода size(), возвращающего для всех контейнеров в STL их размер. Также есть метод empty(), возвращающий логическое значение (true, если вектор пустой).</p>
<p>Размер вектора можно изменить в любой момент, при помощи метода resize. У этого метода может быть один или два параметра. Вызов метода resize(n) изменяет размер вектора до n элементов (длина вектора может как уменьшится, так и увеличиться). Вызов метода resize(n, val) изменяет размер вектора до n элементов, и если при этом размер вектора увеличивается, то новые элементы получают значение, равное val.</p>
<p>Очень часто бывает полезно добавлять элементы в конец вектора по одному и удалять элементы из конца вектора по одному. Для добавления нового элемента, равного val, в конец вектора, используется метод push_back(val). Для удаления последнего элемента вектора используется метод pop_back() - он не возвращает значения.</p>
<p>Добавление элемента в конец вектора осуществляется в среднем за O(1). Это реализовано за счет того, что память для хранения элементов вектора выделяется "с запасом", то есть можно будет добавлять элементы по одному, пока не кончится запас памяти. Если запас памяти исчерпан, выделяется новая память, при этом "запас" размера вектора удваивается.</p>
<p>Очистить вектор можно при помощи метода clear().</p><h2>Вставка и удаление элементов в середину вектора</h2>
<p>Метод erase позволяет удалять из середины вектора один или несколько элементов. Этот метод работает с итераторами. Подробней про его использование можно прочитать <a href="http://ru.cppreference.com/w/cpp/container/vector/erase">в документации</a>.</p>
<p>Метод insert позволяет вставлять в середину вектора новый элемент, или несколько равных элементов, или другой вектор, или фрагмент другого вектора. Этот метод также работает с итераторами и про его использование можно прочитать <a href="http://ru.cppreference.com/w/cpp/container/vector/insert">в документации</a>.</p>
<p>Поскольку вставка и удаление элементов требуют сдвига других элементов вектора, эти операции имеют линейную сложность, то есть выполняются за время, пропорциональное длине вектора.</p><h2>Присваивание и сравнение векторов</h2>
<p>Содержимое одного вектора можно целиком скопировать в другой вектор при помощи операции присваивания: <span class="page_code_style">A = B</span>.</p>
<p>Также вектора можно сравнивать на равенство и неравенство (<span class="page_code_style">A == B</span>, <span class="page_code_style">A != B</span>), и сравнивать их содержимое в лексикографическом порядке (<span class="page_code_style">A &lt; B</span>, <span class="page_code_style">A &lt;= B</span>, <span class="page_code_style">A &gt; B</span>, <span class="page_code_style">A &gt;= B</span>).</p><h2>Создание многомерных векторов</h2>
<p>Элементами вектора могут быть и другие вектора. Например, можно сделать вектор, каждый элемент которого представляет собой вектор целых чисел:</p>
<div class="page_code_style">
<p>vector &lt; vector &lt;int&gt; &gt; a;</p>
</div>
<p>Тем самым, a[i] будет вектором целых чисел, а обращаться к j-му элементу вектора a[i] можно через a[i][j].</p>
<p>Чтобы создать двумерный вектор размером n×m можно внешний вектор объявить размером n, а затем в цикле изменить размер каждого вложенного вектора:</p>
<div class="page_code_style">
<p>vector &lt; vector &lt;int&gt; &gt; a(n);</p>
<p>for (int i = 0; i &lt; n; ++i)<br>&nbsp;&nbsp;&nbsp; a[i].resize(m);</p>
</div>
<p>Но можно сделать это и в одну строку, если передать вторым параметром для конструктора вектора конструктор, который создает вектор целых чисел длины m:</p>
<div class="page_code_style">
<p>vector &lt; vector &lt;int&gt; &gt; a(n, vector&lt;int&gt;(m));</p>
</div>
<p>Заметим, что размеры вложенных векторов могут изменяться и быть различными.</p>
<p>Также можно создавать вектор из стеков, очередей, деков, можно создавать трехмерные векторы и т.д.</p></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>