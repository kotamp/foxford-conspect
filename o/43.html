<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>14. Рекурсия с мемоизацией</title></head><body><h1>14. Рекурсия с мемоизацией</h1>
<div class="page_content_main"><p>При решении задач методом динамического программирования зачастую бывает сложно определить порядок, в котором необходимо заполнять массив значениями. Как правило, это происходит в сложных случаях многомерной динамики, например, в динамическом программировании по подотрезкам.</p>
<p>Мы рассматривали задачу нахождения максимальной подпоследовательности данной строки, являющейся палиндромом, решавшейся при помощи динамического программирования.</p>
<p>В этой задаче была функция <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.882ex" height="2.776ex" viewBox="0 -817.1 2532.7 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-66" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="550" y="0"></use><use xlink:href="#MJMATHI-69" x="940" y="0"></use><use xlink:href="#MJMAIN-2C" x="1285" y="0"></use><use xlink:href="#MJMATHI-6A" x="1730" y="0"></use><use xlink:href="#MJMAIN-29" x="2143" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1">f(i, j)</script>, значение которой равно длине ответа для подотрезка данной строки начиная от символа <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi><mo stretchy=&quot;false&quot;>[</mo><mi>i</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.187ex" height="2.776ex" viewBox="0 -817.1 1372 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-73" x="0" y="0"></use><use xlink:href="#MJMAIN-5B" x="469" y="0"></use><use xlink:href="#MJMATHI-69" x="748" y="0"></use><use xlink:href="#MJMAIN-5D" x="1093" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-2">s[i]</script> и до символа <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi><mo stretchy=&quot;false&quot;>[</mo><mi>j</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.342ex" height="2.776ex" viewBox="0 -817.1 1439 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-73" x="0" y="0"></use><use xlink:href="#MJMAIN-5B" x="469" y="0"></use><use xlink:href="#MJMATHI-6A" x="748" y="0"></use><use xlink:href="#MJMAIN-5D" x="1160" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-3">s[j]</script>. При этом возникает проблема определения порядка обхода двумерного массива.</p>
<p>Вместо того, чтобы определять порядок обхода, попробуем реализовать решение при помощи рекурсии. Для этого запишем функцию вычисления ответа при помощи рекурсии:</p>
<div class="page_code_style">
<p>int f(int i, int j)<br>{<br>&nbsp;&nbsp;&nbsp; if (j &lt; i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>&nbsp;&nbsp;&nbsp; if (i == j)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<br>&nbsp;&nbsp;&nbsp; if (s[i] == s[j])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2 + f(i + 1, j - 1);<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return max(f(i + 1, j), f(i, j - 1));<br>}</p>
</div>
<p>Но такое решение будет работать слишком долго, так так функция будет вызываться многократно для повторяющихся наборов параметров. Чтобы избежать повторяющихся вызовов рекурсии, заведем двумерный массив <span class="page_code_style">ans[n][n]</span>, в котором будет храниться ответ, то есть значение <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.882ex" height="2.776ex" viewBox="0 -817.1 2532.7 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-66" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="550" y="0"></use><use xlink:href="#MJMATHI-69" x="940" y="0"></use><use xlink:href="#MJMAIN-2C" x="1285" y="0"></use><use xlink:href="#MJMATHI-6A" x="1730" y="0"></use><use xlink:href="#MJMAIN-29" x="2143" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-4">f(i, j)</script> будет записываться в элемент массива <span class="page_code_style">ans[i][j]</span>. Если функция будет вызвана для какого-то набора параметров <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.882ex" height="2.776ex" viewBox="0 -817.1 2532.7 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-66" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="550" y="0"></use><use xlink:href="#MJMATHI-69" x="940" y="0"></use><use xlink:href="#MJMAIN-2C" x="1285" y="0"></use><use xlink:href="#MJMATHI-6A" x="1730" y="0"></use><use xlink:href="#MJMAIN-29" x="2143" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-5">f(i, j)</script>, то найдя ответ функция запишет его в соответствующую ячейку массива. При этом в массиве также может быть записано специальное значение, обозначающее, что ответ не был еще посчитан. Будем использовать в качестве такого значения число -1. Таким образом, функция при вызове проверяет, если значение элемента массива не равно -1, то это означает, что функция уже вызывалась для такого набора параметров и ответ был посчитан. В этом случае функция сразу же возвращает вычисленное значение. Иначе функция вызывает себя рекурсивно для нахождения ответа, но после нахождения ответа записывает его в массив, чтобы не вычислять его повторно в следующий раз.</p>
<p>Пример подобной реализации:</p>
<div class="page_code_style">
<p>vector &lt;vector &lt;int&gt; &gt; ans(n, vector&lt;int&gt;(n, -1));<br><br>int f(int i, int j)<br>{<br>&nbsp;&nbsp;&nbsp; if (ans[i][j] != -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ans[i][j];<br>&nbsp;&nbsp;&nbsp; if (j &lt; i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans[i][j] = 0;<br>&nbsp;&nbsp;&nbsp; else if (i == j)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans[i][j] = 1;<br>&nbsp;&nbsp;&nbsp; else if (s[i] == s[j])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans[i][j] = 2 + f(i + 1, j - 1);<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans[i][j] = max(f(i + 1, j), f(i, j - 1));<br>&nbsp;&nbsp;&nbsp; return ans[i][j];<br>}</p>
</div>
<p>Такая технология называется рекурсией с мемоизацией или ленивой динамикой.</p></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>