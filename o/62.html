<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>26. Создание структур Point и Vector для работы с точками и векторами (C++)</title></head><body><h1>26. Создание структур Point и Vector для работы с точками и векторами (C++)</h1>
<div class="page_content_main"><h2>Создание структуры Point, поля структуры</h2>
<p>Для удобства работы с геометрическими примитивами (точками и векторами) полезно хранить точку (вектор) не в виде двух отдельных переменных (координат точки), а в виде одного объекта, содержащего две переменные-координаты. Это можно сделать в рамках концепции объектно-ориентированного программирования — необходимо создать класс «Точка», объекты которого будут содержать два поля — координату x и координату y. В этом случае можно работать с объектом «точка», как с одним целым, а можно и работать с отдельными координатами точки.</p>
<p>В языке C для этого использовалось понятие "структуры", в языке C++ помимо структур появилось понятие "класс". В современном стандарте языка C++ разница между структурами и классами невелика (практически она заключается только в правах доступа к полям и методам, у структур по умолчанию используется public-доступ, у классов - private-доступ), мы будем везде использовать структуры.</p>
<p>Для хранения точек и векторов необходима структура, содержащая два поля: x и y. Подобная структура определяется так:</p>
<div class="page_code_style">
<p>struct Point<br>{<br>&nbsp;&nbsp;&nbsp; double x, y;<br>};</p>
</div>
<p>Обратите внимание, точка с запятой после закрывающей фигурной скобки обязательна!</p>
<p>После этого можно объявлять отдельные объекты структуры Point следующим образом:</p>
<div class="page_code_style">
<p>Point P, Q;</p>
</div>
<p>Для доступа к отдельным полям класса используется так называемая «дот-нотация», когда название поля пишется через точку после идентификатора переменной. Например, задать для точки координаты можно так:</p>
<div class="page_code_style">
<p>P.x = 5;<br>P.y = -10;</p>
</div>
<h2>Конструкторы</h2>
<p>Если полям структуры не присвоить явно какие-либо значения, то в них будет храниться "мусор", как в случае локальных переменных. Поэтому желательно реализовать специальный метод-"конструктор", который будет автоматически вызываться при объявлении переменной типа "структура". Назначение конструктора - инициализация полей структуры.</p>
<p>Конструктор - это метод, название которого совпадает с названием самой структуры. Вот пример объявления структуры Point вместе с конструктором, который инициализирует поля структуры нулями:</p>
<div class="page_code_style">
<p>struct Point<br>{<br>&nbsp;&nbsp;&nbsp; double x, y;<br><br>&nbsp;&nbsp;&nbsp; Point()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0;<br>&nbsp;&nbsp;&nbsp; }<br>};</p>
</div>
<p>Обратите внимание, конструктор не возвращает никакого значения, даже слово void нельзя писать в определении конструктора.</p>
<p>Теперь при объявлении</p>
<div class="page_code_style">
<p>Point P, Q;</p>
</div>
<p>у объявленных переменных поля x и y будут равны 0.</p>
<p>Можно объявлять несколько конструкторов, отличающихся разным набором параметров. Например, добавим конструктор, который принимает на вход два числа — координаты точки (этот конструктор также нужно написать внутри описания структуры):</p>
<div class="page_code_style">
<p>Point(double a, double b)<br>{<br>&nbsp;&nbsp;&nbsp; x = a;<br>&nbsp;&nbsp;&nbsp; y = b;<br>}</p>
</div>
<p>Теперь можно создавать объекты структуры Point, задавая координаты точки. Например, так:</p>
<div class="page_code_style">
<p>Point P(1, -1);</p>
</div>
<p>Другой полезный пример конструктора — объявим структуру "вектор". Хотя структуры "вектор" и "точка" обе имеют два поля x и y, может показаться, что для этих понятий достаточно использовать одну структуру (т.к. каждую точку можно рассматривать, как радиус-вектор). Но лучше для этих понятий сделать две разные структуры, например, у вектора может быть конструктор от двух точек:</p>
<div class="page_code_style">
<p>struct Vector<br>{<br>&nbsp;&nbsp;&nbsp; double x, y;<br><br>&nbsp;&nbsp;&nbsp; Vector(Point A, Point B)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = B.x - A.x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = B.y - A.y;<br>&nbsp;&nbsp;&nbsp; }<br>};</p>
</div>
<p>Теперь можно объявлять векторы следующим образом:</p>
<div class="page_code_style">
<p>Point P, Q;<br>…<br>Vector PQ(P, Q);</p>
</div>
<p>и сразу становится понятно, что вектор PQ — это вектор, проведенный из точки P в точку Q.</p>
<h2>Методы</h2>
<p>У структур также бывают "методы" — это функции, вызывающиеся непосредственно для экземпляров структуры. Например, у точки может быть метод dist, который возвращает расстояние от начала координат до точки, аналогичный метод должен быть и у вектора. Методы можно создавать также внутри описания структуры, например, после конструкторов:</p>
<div class="page_code_style">
<p>double dist()<br>{<br>&nbsp;&nbsp;&nbsp; return sqrt(x * x + y * y);<br>}</p>
</div>
<p>Вызывается метод так:</p>
<div class="page_code_style">
<p>cout &lt;&lt; P.dist() &lt;&lt; endl;</p>
</div>
<h2>Переопределение арифметических операций</h2>
<p>Помимо методов можно также переопределять операторы. Например, хочется чтобы можно было складывать вектора при помощи операции "+" вот таким образом:</p>
<div class="page_code_style">
<p>Vector AB, BC, AC;<br>…<br>AC = AB + BC;</p>
</div>
<p>Для этого необходимо определить функцию со специальным названием "operator+", которая принимает на вход два аргумента типа Vector и возвращает значение типа Vector. Это необходимо сделать путем объявления отдельной функции, то есть вне описания структуры (есть и другой способ, объявление метода структуры, но мы не будем его рассматривать). Функция получает два аргумента типа Vector (левый и правый операнд) и возвращает значение типа Vector;</p>
<p>Вот пример объявления такой функции:</p>
<div class="page_code_style">
<p>Vector operator+ (Vector a, Vector b)<br>{<br>&nbsp;&nbsp;&nbsp; return Vector(a.x + b.x, a.y + b.y);<br>}</p>
</div>
<p>Аналогично определим, например, операцию умножения вектора на число:</p>
<div class="page_code_style">
<p>Vector operator* (Vector a, double d)<br>{<br>&nbsp;&nbsp;&nbsp; return Vector(a.x * d, a.y * d);<br>}<br><br>Vector operator* (double d, Vector a)<br>{<br>&nbsp;&nbsp;&nbsp; return Vector(a.x * d, a.y * d);<br>}</p>
</div>
<p>Заметим, что для того, чтобы можно было умножать вектор на число и число на вектор, то есть менять порядок операндов, необходимо определить две функции.</p>
<p>Аналогично можно определить любые другие операции для точек и векторов. Но можно только переопределять существующие в синтаксисе языка операции, нельзя определить новые операции, которых нет в синтаксисе языка (то есть нельзя, например, определить операцию, обозначаемую знаком "@").</p>
<h2>Переопределение операций ввода-вывода</h2>
<p>Переопределение операций "&gt;&gt;" и "&lt;&lt;" используется для того, чтобы можно было легко считывать и выводить точки и вектора. Определим, например, операции ввода-вывода для точек:</p>
<div class="page_code_style">
<p>istream &amp; operator&gt;&gt; (istream &amp; in, Point &amp; P)<br>{<br>&nbsp;&nbsp;&nbsp; in &gt;&gt; P.x &gt;&gt; P.y;<br>&nbsp;&nbsp;&nbsp; return in;<br>}<br><br>ostream &amp; operator&lt;&lt; (ostream &amp; out, Point &amp; P)<br>{<br>&nbsp;&nbsp;&nbsp; out &lt;&lt; P.x &lt;&lt; " " &lt;&lt; P.y;<br>&nbsp;&nbsp;&nbsp; return out;<br>}</p>
</div>
<p>Теперь можно считывать координаты точки P из потока ввода (например, из cin, но можно и из файла) при помощи:</p>
<div class="page_code_style">
<p>cin &gt;&gt; P;</p>
</div>
<p>а выводить координаты точки (через пробел) при помощи:</p>
<div class="page_code_style">
<p>cout &lt;&lt; P;</p>
</div></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>