<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>18. Алгоритм Дейкстры</title></head><body><h1>18. Алгоритм Дейкстры</h1>
<div class="page_content_main"><h1>Алгоритм Дейкстры</h1>
<p><strong>Алгоритм Дейкстры</strong> назван в честь голландского ученого Эдсгера Дейкстры (Edsger Dijkstra). Алгоритм был предложен в 1959 году для нахождения кратчайших путей от одной вершины до всех остальных в ориентированном взвешенном графе, при условии, что все ребра в графе имеют неотрицательные веса.</p>
<p>Рассмотрим две модели хранения взвешенного графа в памяти. В первой модели (матрица весов, аналог матрицы смежности) будем считать, что вес ребра из вершины i в вершину j равен w[i][j], то есть в матрице w хранятся веса ребра для любых двух вершин. Если из вершины i в вершину j нет ребра, то w[i][j]==INF для некоторого специального значения константы INF. Значение INF следует выбирать исходя из задачи, например, если речь идет о расстояниях между какими-либо населенными пунктами Земли, то можно выбрать значение INF равным <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>10</mn><mn>9</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.379ex" height="2.485ex" viewBox="0 -942.5 1454.9 1069.9" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMAIN-31"></use><use xlink:href="#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="#MJMAIN-39" x="1415" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mn>9</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-1">10^9</script> километров.</p>
<p>Алгоритм Дейкстры относится к так называемым «жадным» алгоритмам. Пусть расстояние от начальной вершины start до вершины i хранится в массиве dist[i]. Начальные значения dist[start]=0, dist[i]=INF для всех остальных вершин i. То есть в самом начале алгоритму известен путь из вершины start до вершины start длины 0, а до остальных вершин кратчайшие пути неизвестны. Между тем алгоритм будет постепенно улучшать значения в массиве dist, в результате получит кратчайшие расстояния до всех вершин.</p>
<p>Основная идея для улучшения называется «релаксацией ребра». Пусть из вершины i в вершину j есть ребро веса w[i][j], при этом выполнено неравенство dist[i] + w[i][j] &lt; dist[j]. То есть можно построить маршрут из начальной вершины до вершины i и добавить к нему ребро из i в j, и суммарная стоимость такого маршрута будет меньше, чем известная ранее стоимость маршрута из начальной вершины в вершину j. Тогда можно улучшить значение dist[j], присвоив dist[j] = dist[i] + w[i][j].</p>
<p>В алгоритме Дейкстры вершины красятся в два цвета, будем говорить, что вершина «неокрашенная» или «окрашенная». Изначально все вершины неокрашенные. Если алгоритм Дейкстры покрасил вершину i, то это означает, что найденное значение dist[i] является наилучшим возможным и в последствии не будет улучшаться, то есть значение dist[i] является кратчайшим расстоянием от начальной вершины до вершины i. Если же вершина не покрашена, то величина dist[i] для такой вершины i равна кратчайшему пути из вершины start до вершины i, который проходит только по покрашенным вершинам (за исключением самой вершины i).</p>
<p>На каждом шаге алгоритма Дейкстры красится одна новая вершина. В качестве такой вершины выбирается неокрашенная вершина i с наименьшим значением D[i]. Затем рассматриваются все ребра, исходящие из вершины i, и производится релаксация этих ребер, то есть улучшаются расстояния до вершин, смежных с i.</p>
<p>Алгоритм заканчивается, когда на очередном шаге не останется неокрашенных вершин или если расстояние до всех неокрашенных вершин будет равно INF (то есть эти вершины являются недостижимыми).</p>
<p>Запишем алгоритм Дейкстры. Пусть <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.611ex" viewBox="0 -566.3 600.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-2">n</script> — число вершин в графе, вершины пронумерованы от 0 до <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.398ex" height="2.194ex" viewBox="0 -754.4 2323.9 944.5" role="img" focusable="false" style="vertical-align: -0.442ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use><use xlink:href="#MJMAIN-2212" x="822" y="0"></use><use xlink:href="#MJMAIN-31" x="1823" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>−</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3">n-1</script>. Номер начальной вершины — start и веса ребер хранятся в матрице w.</p>
<h3>Реализация на языке C++</h3>
<div class="page_code_style">const int INF = 1000000000;<br>vector &lt;int&gt; dist(n, INF);<br>dist[start] = 0;<br>vector &lt;bool&gt; used(n);<br>int min_dist = 0;<br>int min_vertex = start;<br>while (min_dist &lt; INF)<br>{<br>&nbsp;&nbsp;&nbsp; int i = min_vertex;<br>&nbsp;&nbsp;&nbsp; used[i] = true;<br>&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; n; ++j)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dist[i] + w[i][j] &lt; dist[j])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dist[j] = dist[i] + w[i][j];<br>&nbsp;&nbsp;&nbsp; min_dist = INF;<br>&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; n; ++j)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!used[j] &amp;&amp; dist[j] &lt; min_dist)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_dist = dist[j];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_vertex = j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>}</div>
<h3>Реализация на языке Python</h3>
<div class="page_code_style">
<p>INF = 10 ** 10<br>dist = [INF] * n<br> dist[start] = 0<br>used = [False] * n<br>min_dist = 0<br>min_vertex = start<br> while min_dist &lt; INF:<br>&nbsp; &nbsp; i = min_vertex <br>&nbsp; &nbsp; used[i] = True <br>&nbsp; &nbsp; for j in range(n): <br>&nbsp; &nbsp; &nbsp; &nbsp; if dist[i] + w[i][j] &lt; dist[j]: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist[j] = dist[i] + w[i][j] <br>&nbsp; &nbsp; min_dist = INF<br>&nbsp; &nbsp; for j in range(n):<br>&nbsp; &nbsp; &nbsp; &nbsp; if not used[j] and dist[j] &lt; min_dist:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_dist = dist[j]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_vertex = j</p>
</div>
<p>Массив used будет хранить информацию о том, была ли покрашена вершина. Сначала инициализируются массивы dist и used. Затем запускается внешний цикл алгоритма, который выбирает неокрашенную вершину с минимальным расстоянием, номер этой вершины хранится в переменной min_vertex, а расстояние до этой вершины — в переменной min_dist. Если же min_dist оказывается равно INF, то значит все неокрашенные вершины являются недостижимыми и алгоритм заканчивает свою работу. Иначе найденная вершина окрашивается и после этого релаксируются все ребра, исходящие из этой вершины.</p>
<p>Данный алгоритм имеет сложность <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.032ex" height="3.068ex" viewBox="0 -942.5 2596.9 1320.7" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="#MJMAIN-32" x="849" y="513"></use></g><use xlink:href="#MJMAIN-29" x="2207" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-4">O(n^2)</script>, так как внешний цикл может быть выполнен до n раз, внутри него содержится два цикла, каждый из которых также выполняется n раз.</p>
<p>Для восстановления ответа, то есть для нахождения пути из начальной вершины до всех остальных, необходимо построить дерево кратчайших путей. Это дерево будет состоять из тех ребер, которые были успешно срелаксированы в результате исполнения алгоритма. То есть если происходит релаксация ребра из i в j, то теперь кратчайший маршрут из вершины start до вершины j должен проходить через вершину i и затем содержать ребро i-j. Тем самым вершина i становится предшественником вершины j на кратчайшем пути из начальной вершины до вершины j.</p>
<p>Рассмотрим реализацию алгоритм Дейкстры с восстановлением ответа на графе, хранимым в виде списка смежности на языке C++. Ребро из вершины i в вершину j веса wt будет хранить в виде пары (j, wt), список ребер, исходящих из вершины i будет храниться в векторе w[i]. То есть списки смежности w будут объявлены так:</p>
<div class="page_code_style">
<p>vector &lt;vector &lt;pair &lt;int, int &gt; &gt; &gt; w;</p>
</div>
<p>Реализация считывания ребер графа (из номеров вершин будем вычитать число 1 для нумерации с нуля, рассматриваем ориентированный граф, то есть не дублируем ребро):</p>
<div class="page_code_style">
<p>for (k = 0; k &lt; m; ++k)<br>{<br>&nbsp;&nbsp;&nbsp; int i, j, wt;<br>&nbsp;&nbsp;&nbsp; cin &gt;&gt; i &gt;&gt; j &gt;&gt; wt;<br>&nbsp;&nbsp;&nbsp; w[i - 1].push_back(make_pair(j - 1, wt));<br>}</p>
</div>
<p>Тогда при обработки вершины i вместо перебора всех других вершин мы рассматриваем только ребра, исходящие из данной вершины.</p>
<div class="page_code_style">const int INF = 1000000000;<br>vector &lt;int&gt; dist(n, INF);<br>dist[start] = 0;<br>vector &lt;int&gt; prev(n, -1);<br>vector &lt;bool&gt; used(n);<br>int min_dist = 0;<br>int min_vertex = start;<br>while (min_dist &lt; INF)<br>{<br>&nbsp;&nbsp;&nbsp; int i = min_vertex;<br>&nbsp;&nbsp;&nbsp; used[i] = true;<br>&nbsp;&nbsp;&nbsp; for (auto edge: w[i])<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j = edge.first;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int wt = edge.second;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dist[i] + wt &lt; dist[j])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dist[j] = dist[i] + wt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev[j] = i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; min_dist = INF;<br>&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; n; ++j)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!used[j] &amp;&amp; dist[j] &lt; min_dist)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_dist = dist[j];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_vertex = j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>}</div>
<p>Восстановление ответа производится аналогично поиску в ширину или в глубину.</p>
<div class="page_code_style">
<p>vector &lt;int&gt; path;<br>while (j != -1)<br>{<br>&nbsp; &nbsp; path.push_back(j);<br>&nbsp; &nbsp; j = prev[j];<br>}<br>reverse(path.begin(), path.end());</p>
</div>
<p>Рассмотрим реализацию алгоритм Дейкстры с восстановлением ответа на графе, хранимым в виде списка смежности на языке Python. Набор вершин, смежных с вершиной i будет храниться в множестве w[i]. Также необходимо хранить веса ребер, будем считать, что для хранения весов ребер используется словарь weight, где ключом является кортеж из двух вершин. То есть вес ребра из i в j хранится в элементе weight[i, j] словаря весов.</p>
<div class="page_code_style">
<p>dist = [INF] * n<br> dist[start] = 0<br> prev = [None] * n<br>used = [False] * n<br>min_dist = 0<br>min_vertex = start<br> while min_dist &lt; INF:<br>&nbsp; &nbsp; i = min_vertex<br>&nbsp; &nbsp; used[i] = True<br>&nbsp; &nbsp; for j in w[i]:<br>&nbsp; &nbsp; &nbsp; &nbsp; if dist[i] + weight[i, j] &lt; dist[j]:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist[j] = dist[i] + weight[i, j] <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev[j] = i<br>&nbsp; &nbsp; min_dist = INF<br>&nbsp; &nbsp; for i in range(n): <br>&nbsp; &nbsp; if not used[i] and dist[i] &lt; min_dist: <br>&nbsp; &nbsp; &nbsp; &nbsp; min_dist = dist[i] <br>&nbsp; &nbsp; &nbsp; &nbsp; min_vertex = i</p>
</div>
<p>Для нахождения кратчайшего пути из вершины start до вершины j будем переходить от каждой вершины к ее предшественнику:</p>
<div class="page_code_style">
<p>path = []<br>while j is not None:<br>&nbsp; &nbsp; path.append(j) <br>&nbsp; &nbsp; j = prev[j] <br>path = path[::-1]</p>
</div>
<p>Алгоритм Дейкстры применим только в том случае, когда веса всех ребер неотрицательные. Это гарантирует то, что после окраски расстояние до вершины не может быть улучшено. Если в графе могут быть ребра отрицательного веса, то следует использовать другие алгоритмы.</p><h1>Реализация алгоритма Дейкстры с использованием кучи или контейнера set в STL</h1>
<p>Алгоритм Дейкстры в ранее приведенной реализации имеет сложность <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.032ex" height="3.068ex" viewBox="0 -942.5 2596.9 1320.7" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="#MJMAIN-32" x="849" y="513"></use></g><use xlink:href="#MJMAIN-29" x="2207" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-5">O(n^2)</script>. В этой реализации производится выбор элемента с наименьшим расстоянием до него, что производится путем просмотра всех вершин. Если хранить все неокрашенные вершины в куче или в контейнере set STL (которое реализовано при помощи сбалансированного дерева поиска), то поиск очередной вершины для окрашивания можно производить более оптимально.</p>
<p>Но обновление расстояния до другой&nbsp; в этом случае будет выполняться за <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>log</mi><mo>&amp;#x2061;</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.336ex" height="2.776ex" viewBox="0 -817.1 3589.2 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="#MJMAIN-6C"></use><use xlink:href="#MJMAIN-6F" x="278" y="0"></use><use xlink:href="#MJMAIN-67" x="779" y="0"></use></g><use xlink:href="#MJMATHI-6E" x="2599" y="0"></use><use xlink:href="#MJMAIN-29" x="3199" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-6">O(\log n)</script>, так как это требует перестройки кучи или дерева поиска. Если в графе m ребер, то максимальное число релаксаций ребер также будет не больше m и суммарная сложность всех релаксаций будет <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>m</mi><mi>log</mi><mo>&amp;#x2061;</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.764ex" height="2.776ex" viewBox="0 -817.1 4634.3 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><use xlink:href="#MJMATHI-6D" x="1153" y="0"></use><g transform="translate(2198,0)"><use xlink:href="#MJMAIN-6C"></use><use xlink:href="#MJMAIN-6F" x="278" y="0"></use><use xlink:href="#MJMAIN-67" x="779" y="0"></use></g><use xlink:href="#MJMATHI-6E" x="3644" y="0"></use><use xlink:href="#MJMAIN-29" x="4244" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-7">O(m \log n)</script>. Таким образом, алгоритм Дейкстры с использованием кучи будет иметь сложность <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mi>log</mi><mo>&amp;#x2061;</mo><mi>n</mi><mo>+</mo><mi>m</mi><mi>log</mi><mo>&amp;#x2061;</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=&quot;false&quot;>)</mo><mi>log</mi><mo>&amp;#x2061;</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="40.046ex" height="2.776ex" viewBox="0 -817.1 17241.9 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><use xlink:href="#MJMATHI-6E" x="1153" y="0"></use><g transform="translate(1920,0)"><use xlink:href="#MJMAIN-6C"></use><use xlink:href="#MJMAIN-6F" x="278" y="0"></use><use xlink:href="#MJMAIN-67" x="779" y="0"></use></g><use xlink:href="#MJMATHI-6E" x="3366" y="0"></use><use xlink:href="#MJMAIN-2B" x="4189" y="0"></use><use xlink:href="#MJMATHI-6D" x="5189" y="0"></use><g transform="translate(6234,0)"><use xlink:href="#MJMAIN-6C"></use><use xlink:href="#MJMAIN-6F" x="278" y="0"></use><use xlink:href="#MJMAIN-67" x="779" y="0"></use></g><use xlink:href="#MJMATHI-6E" x="7681" y="0"></use><use xlink:href="#MJMAIN-29" x="8281" y="0"></use><use xlink:href="#MJMAIN-3D" x="8948" y="0"></use><use xlink:href="#MJMATHI-4F" x="10005" y="0"></use><use xlink:href="#MJMAIN-28" x="10768" y="0"></use><use xlink:href="#MJMAIN-28" x="11158" y="0"></use><use xlink:href="#MJMATHI-6E" x="11547" y="0"></use><use xlink:href="#MJMAIN-2B" x="12370" y="0"></use><use xlink:href="#MJMATHI-6D" x="13371" y="0"></use><use xlink:href="#MJMAIN-29" x="14249" y="0"></use><g transform="translate(14805,0)"><use xlink:href="#MJMAIN-6C"></use><use xlink:href="#MJMAIN-6F" x="278" y="0"></use><use xlink:href="#MJMAIN-67" x="779" y="0"></use></g><use xlink:href="#MJMATHI-6E" x="16251" y="0"></use><use xlink:href="#MJMAIN-29" x="16852" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-8">O(n \log n+m \log n)=O((n+m) \log n)</script>. Если граф — разреженный, то такой алгоритм работает существенно быстрее, чем обычный алгоритм Дейкстры, но на плотных графах (если <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi><mo>&amp;#x223C;</mo><msup><mi>n</mi><mn>2</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.588ex" height="2.485ex" viewBox="0 -942.5 3267 1069.9" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-6D" x="0" y="0"></use><use xlink:href="#MJMAIN-223C" x="1156" y="0"></use><g transform="translate(2212,0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="#MJMAIN-32" x="849" y="513"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>m</mi><mo>∼</mo><msup><mi>n</mi><mn>2</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-9">m\sim n^2</script>) он, наоборот, менее эффективен, чем простая реализация Дейкстры.</p>
<p>Приведем реализацию алгоритма Дейкстры с использованием структуры set на языке STL. Нам необходимо извлекать из set элемент с наименьшим расстоянием до него, а также узнавать при этом номер извлеченной вершины. Для этого в структуре set мы будем хранить пары значений (dist[i], i), то есть пары, у который первый компонент - расстояние до вершины, второй компонент - номер вершины. Поскольку пары сортируются лексикографически по полю first, а при равенстве - по полю second, то объекты в нашем set будут упорядочены прежде всего по возрастанию значения dist и в начале set будет храниться вершина с минимальным значением set.</p>
<div class="page_code_style">vector&lt;int&gt; dist(n, INF);<br>dist[start] = 0;<br>set&lt;pair&lt;int, int&gt; &gt; unused;<br>unused.insert(make_pair(0, start));<br>while (!unused.empty())<br>{<br>&nbsp;&nbsp;&nbsp; int i = unused.begin()-&gt;second;<br>&nbsp;&nbsp;&nbsp; unused.erase(unused.begin());<br>&nbsp;&nbsp;&nbsp; for (auto edge : w[i])<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j = edge.first;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int wt = edge.second;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (dist[i] + wt &lt; dist[j])<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unused.erase(make_pair(dist[j], j)); <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dist[j] = dist[i] + wt;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unused.insert(make_pair(dist[j], j));<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</div>
<p>При этом в set мы будем хранить только вершины, которые достижимы из начальной, то есть для них значение dist меньше 0. Поэтому в самом начале в set кладется только одна начальная вершина. Внутри главного цикла из set удаляется начальный элемент, а дальше при обработке вершины рассматриваются все исходящие из нее ребра и для каждого ребра соответствующая ему пара удаляется из set (если вершина не была ранее достижима, т.е. до нее расстояние было равно INF, то операция удаления ничего не сделает, но и не приведет к ошибке), а потом в set добавляется новая пара, соответствующая измененному значению расстояния до данной вершины.</p></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>