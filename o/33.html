<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>12. Задачи на отрезки на прямой</title></head><body><h1>12. Задачи на отрезки на прямой</h1>
<div class="page_content_main"><p>Рассмотрим следующую задачу. На прямой дано некоторое количество отрезков. Необходимо найти, какое наибольшее количество отрезков может одновременно пересекаться в одной точке.</p>
<p>Для решения этой задачи достаточно понять, что ответом (точкой, в которой пересекается наибольшее количество отрезков) является один из концов отрезков (иначе можно «передвинуть» ответ так, чтобы он совпал с каким либо из концов отрезков). Но перебирая все концы отрезков и для каждого из них подсчитывая количество пересечений с другими отрезками (то есть перебирая все другие отрезки), получится решения сложности <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.032ex" height="3.068ex" viewBox="0 -942.5 2596.9 1320.7" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="#MJMAIN-32" x="849" y="513"></use></g><use xlink:href="#MJMAIN-29" x="2207" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1">O(n^2)</script>, где <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.611ex" viewBox="0 -566.3 600.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-2">n</script> — количество данных нам отрезков. Можно решить задачу за меньшую сложность.</p>
<p>Для этого будем двигаться по числовой прямой слева направо, считая количество пересечений отрезков с текущим положением рассматриваемой точки. Эта величина (количество пересечений) будет увеличиваться на 1, при прохождении через начало отрезка, и уменьшаться на 1, при прохождении через конец отрезка. Только эти точки представляют интерес, поскольку в этих точках меняется значение интересующего нас показателя. Будем называть интересующие нас точки <strong>событиями</strong>, то есть событиями являются начала и концы отрезков.</p>
<p>В этом случае для решения задачи нам нужно считать координаты начал и концов всех отрезков и составить список событий на прямой. Затем необходимо упорядочить список событий по возрастанию их координаты, пройти по списку событий, увеличивая значение счетчика на 1, при встрече начала отрезка, и уменьшая значение счетчика на 1 на концах отрезков. Одновременно с этим нужно искать максимальное значение счетчика, что и будет ответом на нашу задачу.</p>
<p>Переменная типа «событие» должна хранить в себе минимум два значения: координату точки <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.611ex" viewBox="0 -566.3 572.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-3">x</script> и тип события, которое позволяет отличать события типа «начало отрезка» от события типа «конец отрезка». Для представления событий будем использоваться кортежи, при этом поскольку нам необходимо сортировать события по возрастанию координаты, а кортежи сортируются в лексикографическом порядке (то есть прежде всего по первому элементу кортежа, а при равном значении первого элемента — по второму), то первым элементом кортежа будет координата <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.611ex" viewBox="0 -566.3 572.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-4">x</script> события.</p>
<p>При равном значении координаты <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.611ex" viewBox="0 -566.3 572.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-5">x</script> необходимо, чтобы сначала обрабатывались начала отрезков, а потом концы отрезков, в этом случае если в одной точке есть и начала отрезков, и концы отрезков, то мы посчитаем эту точку, как принадлежащую всем отрезкам, и начинающимся, и заканчивающимся в этой точке. Поэтому будем кодировать начала отрезков числом -1, а концы отрезков числом 1, это будет вторым элементом кортежа типа событие.&nbsp;</p>
<p>Итак, считывание всех концов отрезков и создание списка событий можно реализовать следующим образом:</p>
<h3>Пример реализации на языке C++</h3>
<div class="page_code_style">
<p>int n;<br>cin &gt;&gt; n;<br>vector &lt;pair &lt;int, int&gt; &gt; Events;<br>for (int i = 0; i &lt; n; ++i) {<br>&nbsp;&nbsp;&nbsp; int l, r;<br>&nbsp;&nbsp;&nbsp; cin &gt;&gt; l &gt;&gt; r;<br>&nbsp;&nbsp;&nbsp; Events.push_back(make_pair(l, -1));<br>&nbsp;&nbsp;&nbsp; Events.push_back(make_pair(r, 1));<br>}</p>
</div>
<h3>Пример реализации на языке Python</h3>
<div class="page_code_style">
<p>n = int(input())&nbsp;<br>Events = []<br>for i in range(n):&nbsp;<br>&nbsp; &nbsp;l, r = map(int, input().split())&nbsp;<br>&nbsp; &nbsp;Events.append((l, -1))&nbsp;<br>&nbsp; &nbsp;Events.append((r, 1))</p>
</div>
<p>В некоторых задачах может оказаться необходимым сохранение информации о номере отрезка, в этом случае в кортеж добавляется дополнительное поле, в которое необходимо записать значение переменной i.</p>
<p>Дальнейшее решение задачи просто. Заведем переменную count для подсчета количества отрезков, которые пересекаются. Тогда для поддержания значения count необходимо из значения count вычитать значение типа отрезка (которое равно -1 для начала и 1 для конца) и искать максимальное значение величины count.</p>
<h3>Пример реализации на языке С++</h3>
<div class="page_code_style">
<p>sort(Events.begin(), Events.end());<br>int count = 0;<br>int ans = 0;<br>for (auto event in Events) {<br>&nbsp;&nbsp;&nbsp; int x = event.first;<br>&nbsp; &nbsp; int type = events.second;<br>&nbsp;&nbsp;&nbsp; count -= type;<br>&nbsp;&nbsp;&nbsp; ans = max(ans, count);<br>}</p>
</div>
<h3>Пример реализации на языке Python</h3>
<div class="page_code_style">
<p>count = 0<br>ans = 0<br>for x, type in sorted(Events):&nbsp;<br>&nbsp; &nbsp;count -= type&nbsp;<br>&nbsp; &nbsp;ans = max(ans, count)&nbsp;</p>
</div>
<p>Слегка модифицировав это решение, можно научиться, например, считать длину объединения всех отрезков. Объединение отрезков представляет собой также набор отрезков, концы которых совпадают с какими-либо событиями (то есть с концами данных отрезков). Тогда началом очередного отрезка из объединения данных отрезков будет точка, в которой значение count меняется с 0 на 1, что можно также проверить условием count равно 1 и тип события — начало отрезка (после обработки отрезка), а конец объединения отрезка — точка, в которой значение count становится равно 0. В случае, если встретилась точка, являющаяся началом одного из отрезков объединения, запомним ее координату в переменной last, а если встретилась точка — конец одного из отрезков объединения, вычтем из ее координат last и добавим эту величину к ответу.</p>
<h3>Пример реализации на языке C++</h3>
<div class="page_code_style">
<p>sort(Events.begin(), Events.end());<br>int count = 0;<br>int ans = 0;<br>int last;<br>for (auto event in Events) {<br>&nbsp;&nbsp;&nbsp; int x = event.first;<br>&nbsp; &nbsp; int type = events.second;<br>&nbsp;&nbsp;&nbsp; count -= type;<br>&nbsp;&nbsp;&nbsp; if (count == 1 &amp;&amp; type == -1)<br>&nbsp; &nbsp; &nbsp;&nbsp; last = x;<br>&nbsp;&nbsp; if (count == 0)<br>&nbsp; &nbsp; &nbsp;&nbsp; ans += x — last;<br>}</p>
</div>
<h3>Пример реализации на языке Python</h3>
<div class="page_code_style">
<p>count = 0<br>ans = 0<br>for x, type in sorted(Events):&nbsp;<br>&nbsp; &nbsp;count -= type&nbsp;<br>&nbsp; &nbsp;if count == 1 and type == -1:<br>&nbsp; &nbsp; &nbsp; &nbsp;last = x<br>&nbsp; &nbsp;if count == 0:<br>&nbsp; &nbsp; &nbsp; &nbsp;ans += x — last&nbsp;</p>
</div></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>