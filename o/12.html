<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>4. Работа со строками в С</title></head><body><h1>4. Работа со строками в С</h1>
<div class="page_content_main"><p>Строка — это последовательность ASCII или UNICODE символов.</p>
<p><strong>Строки в C</strong>, как и в большинстве языков программирования высокого уровня рассматриваются как отдельный тип, входящий в систему базовых типов языка. Так как язык C по своему происхождению является языком системного программирования, то <strong>строковый тип данных в C как таковой отсутствует, а в качестве строк в С используются обычные массивы символов</strong>.</p>
<p>Исторически сложилось два представления формата строк:</p>
<ol>
<li>формат ANSI;</li>
<li>cтроки с завершающим нулем (используется в C).</li>
</ol>
<p>Формат ANSI устанавливает, что значением первой позиции в строке является ее длина, а затем следуют сами символы строки. Например, представление строки "Моя строка!" будет следующим:</p>
<p><span class="page_code_style">11 'М' 'о' 'я' ' ' 'с' 'т' 'р' 'о' 'к' 'а' '!'</span><br> В строках с завершающим нулем, значащие символы строки указываются с первой позиции, а признаком завершения строки является значение ноль. Представление рассмотренной ранее строки в этом формате имеет вид:</p>
<p><span class="page_code_style">'М' 'о' 'я' ' ' 'с' 'т' 'р' 'о' 'к' 'а' '!' 0</span></p>
<h2>Объявление строк в C</h2>
<p>Строки реализуются посредством массивов символов. Поэтому объявление ASCII строки имеет следующий синтаксис:</p>
<p><span class="page_code_style">char имя[длина];</span><br> Объявление <strong>строки в С</strong>&nbsp;имеет тот же синтаксис, что и объявление одномерного символьного массива. Длина строки должна представлять собой целочисленное значение (в стандарте C89 – константа, в стандарте C99 может быть выражением). Длина строки указывается с учетом одного символа на хранение завершающего нуля, поэтому максимальное количество значащих символов в строке на единицу меньше ее длины. Например, строка может содержать максимально двадцать символов, если объявлена следующим образом:<br> char str[21]; Инициализация строки в С осуществляется при ее объявлении, используя следующий синтаксис:<br> char str[длина] = строковый литерал;</p>
<p>Строковый литерал – строка ASCII символов заключенных в двойные кавычки. Примеры объявления строк с инициализацией:</p>
<p><span class="page_code_style">char str1[20] = "Введите значение: ", str2[20] = "";</span></p>
<p>Пример:</p>
<p><span class="page_code_style">const char message[] = "Сообщение об ошибке!";</span></p>
<h2><strong>Работа со строками в С</strong></h2>
<p>Так как строки на языке С являются массивами символов, то к любому символу строки можно обратиться по его индексу. Для этого используется синтаксис обращения к элементу массива, поэтому первый символ в строке имеет индекс ноль. Например, в следующем фрагменте программы в строке str осуществляется замена всех символов 'a' на символы 'A' и наоборот.</p>
<div class="page_code_style">for(int i = 0; str[i] != 0; i++)<br> {<br>&nbsp;&nbsp;&nbsp; if (str[i] == 'a') str[i] = 'A';<br>&nbsp;&nbsp;&nbsp; else if (str[i] == 'A') str[i] = 'a';<br> }</div>
<h2>Массивы строк в С</h2>
<p>Объявление массивов строк в языке С также возможно. Для этого используются двумерные массивы символов, что имеет следующий синтаксис:<br> char имя[количество][длина];</p>
<p>Первым размером матрицы указывается количество строк в массиве, а вторым – максимальная (с учетом завершающего нуля) длина каждой строки. Например, объявление массива из пяти строк максимальной длиной 30 значащих символов будет иметь вид:</p>
<p><span class="page_code_style">char strs[5][31];</span></p>
<p>При объявлении массивов строк можно производить инициализацию: <br><span class="page_code_style"> char имя[количество][длина] = {строковый литерал №1, … строковый литерал №N};</span></p>
<p>Число строковых литералов должно быть меньше или равно количеству строк в массиве. Если число строковых литералов меньше размера массива, то все остальные элементы инициализируются пустыми строками. Длина каждого строкового литерала должна быть строго меньше значения длины строки (для записи завершающего нуля).</p>
<p>Например:</p>
<div class="page_code_style">char days[12][10] = {<br>&nbsp;&nbsp;&nbsp; "Январь", "Февраль", "Март", ”Апрель", "Май",<br>&nbsp;&nbsp;&nbsp; "Июнь", "Июль", "Август", "Сентябрь","Октябрь",<br>&nbsp;&nbsp;&nbsp; "Ноябрь", "Декабрь"<br>};</div>
<p>При объявлении массивов строк с инициализацией допускается не указывать количество строк в квадратных скобках. В таком случае, количество строк в массиве будет определено автоматически по числу инициализирующих строковых литералов.<br> Например, массив из семи строк:</p>
<div class="page_code_style">char days[][12] = {<br>&nbsp;&nbsp; &nbsp;"Понедельник", "Вторник", "Среда", "Четверг",<br>&nbsp;&nbsp; &nbsp;"Пятница", "Суббота", "Воскресенье"<br>};</div>
<h2>Функции для работы со строками в С</h2>
<p>Все библиотечные функции, предназначенные для работы со строками, можно разделить на три группы:</p>
<ol>
<li>ввод и вывод строк;</li>
<li>преобразование строк;</li>
<li>обработка строк.</li>
</ol>
<h2>Ввод и вывод строк в С</h2>
<p>Для ввода и вывода строковой информации можно использовать функции форматированного ввода и вывода (printf и scanf). Для этого в строке формата при вводе или выводе строковой переменной необходимо указать спецификатор типа %s. Например, ввод и последующий вывод строковой переменной будет иметь вид:</p>
<div class="page_code_style">
<p>char str[31] = "";<br> printf("Введите строку: ");<br> scanf("%30s”,str);<br> printf("Вы ввели: %s”,str);</p>
</div>
<p>Недостатком функции scanf при вводе строковых данных является то, что символами разделителями данной функции являются:</p>
<ol>
<li>перевод строки,</li>
<li>табуляция;</li>
<li>пробел.</li>
</ol>
<p>Поэтому, используя данную функцию невозможно ввести строку, содержащую несколько слов, разделенных пробелами или табуляциями. Например, если в предыдущей программе пользователь введет строку: "Сообщение из нескольких слов", то на экране будет выведено только "Сообщение".<br> Для ввода и вывода строк в библиотеке stdio.h содержатся специализированные функции gets и puts.</p>
<p>Функция gets предназначена для ввода строк и имеет следующий заголовок:<br> <span class="page_code_style">char * gets(char *buffer);</span></p>
<p>Между тем использовать функцию <span class="page_code_style">gets</span> категорически не рекомендуется, ввиду того, что она не контролирует выход за границу строки, что может произвести к ошибкам. Вместо нее используется функция fgets с тремя параметрами:</p>
<p><span class="page_code_style">char * fgets(char * buffer, int size, FILE * stream);</span></p>
<p>где buffer - строка для записи результата, size - максимальное количество байт, которое запишет функция fgets, stream - файловый объект для чтения данных, для чтения с клавиатуры нужно указать stdin. Эта функция читает символы со стандартного ввода, пока не считает n - 1 символ или символ конца строки, потом запишет считанные символы в строку и добавит нулевой символ. При этом функция fgets записывает в том символ конца строки в данную строку, что нужно учитывать.</p>
<p>Функция puts предназначена для вывода строк и имеет следующий заголовок:<br> <span class="page_code_style">int puts(const char *string);</span></p>
<p>Простейшая программа: ввод и вывод строки с использованием функций fgets и puts будет иметь вид:</p>
<div class="page_code_style">char str[102] = "";<br> printf("Введите строку: ");<br>fgets(str, 102, stdin);<br> printf("Вы ввели: "); <br> puts(str);</div>
<p>Для считывания одного символа можно использовать функцию <span class="page_code_style">fgetc(FILE * stream)</span>. Она считывает один символ и возвращает значение этого символа, преобразованное к типу int, если же считывание не удалось, то возвращается специальная константа EOF, равная -1. Функция возвращает значение -1 для того, чтобы можно было обрабатывать ситуацию конца файла, посимвольное чтение до конца файла можно реализовать следующим образом:</p>

<div class="page_code_style">
<p>int c;<br>while ((c = fgetc(stdin)) != EOF) {<br>&nbsp;&nbsp;&nbsp; // Обработка символа<br>}</p>
</div>
<p>Для вывода одного символа можно использовать функцию&nbsp; <span class="page_code_style">int fputc(int c, FILE *stream);</span>.</p>
<p>Помимо функций ввода и вывода в потоки в библиотеке stdio.h присутствуют функции форматированного ввода и вывода в строки. Функция форматированного ввода из строки имеет следующий заголовок:</p>
<div class="page_code_style">
<p>int sscanf(const char * restrict buffer, const char * restrict string, [address] …);&nbsp;</p>
</div>
<p>Функции форматированного вывода в строку имеют следующие заголовки:</p>
<div class="page_code_style">int sprintf(char * restrict buffer,<br> const char * restrict format, [argument] …);<br> int snprintf(char * restrict buffer, size_t maxsize,<br> const char * restrict format, [argument] …);</div>
<h2>Преобразование строк</h2>
<p>В С для преобразования строк, содержащих числа, в численные значения в библиотеке stdlib.h <br> предусмотрен следующий набор функций:<br> <span class="page_code_style">double atof(const char *string);</span> // преобразование строки в число типа double<br> <span class="page_code_style">int atoi(const char *string);</span> // преобразование строки в число типа int<br> <span class="page_code_style">long int atol(const char *string);</span> // преобразование строки в число типа long int<br> <span class="page_code_style">long long int atoll(const char *string);</span> // преобразование строки в число типа long long int</p>
<p>Корректное представление вещественного числа в текстовой строке должно удовлетворять формату:</p>
<p style="padding-left: 20px;">[ ][{+|-}][цифры][.цифры][{e|E}[{+|-}]цифры]</p>
<p>После символов E, e указывается порядок числа. Корректное представление целого числа в текстовой строке должно удовлетворять формату:</p>
<p style="padding-left: 20px;">[ ] [{+|-}] цифры</p>
<p>Помимо приведенных выше функций в библиотеке stdlib.h доступны также следующие функции преобразования строк в вещественные числа:</p>
<div class="page_code_style">float strtof(const char * restrict string, char ** restrict endptr);<br>double strtod(const char * restrict string, char ** restrict endptr);<br>long double strtold(const char * restrict string,char ** restrict endptr);</div>
<p>Аналогичные функции присутствуют и для преобразования строк в целочисленные значения:</p>
<div class="page_code_style">long int strtol(const char * restrict string, char ** restrict endptr, int base);<br>unsigned long strtoul(const char * restrict string,<br>char ** restrict endptr, int base);<br>long long int strtoll(const char * restrict string,<br>char ** restrict endptr, int base);<br>unsigned long long strtoull(const char * restrict string,char ** restrict endptr, int base);</div>
<p>Функции обратного преобразования (численные значения в строки) в библиотеке stdlib.h присутствуют, но они не регламентированы стандартом, и рассматриваться не будут. Для преобразования численных значений в строковые наиболее удобно использовать функции sprintf и snprintf.</p>
<h2>Обработка строк</h2>
<p>В библиотеке string.h содержаться функции для различных действий над строками. <br> Функция вычисления длины строки:<br> <span class="page_code_style">size_t strlen(const char *string);</span></p>
<p>Пример:</p>
<div class="page_code_style">char str[] = "1234";<br> int n = strlen(str); //n == 4</div>
<p>Функции копирования строк:</p>
<div class="page_code_style">char * strcpy(char * restrict dst, const char * restrict src);<br> char * strncpy(char * restrict dst, const char * restrict src, size_t num);</div>
<p>Функции сравнения строк:</p>
<div class="page_code_style">int strcmp(const char *string1, const char *string2);<br> int strncmp(const char *string1, const char *string2,size_t num);</div>
<p>Функции осуществляют сравнение строк по алфавиту и возвращают:</p>
<p style="padding-left: 20px;">положительное значение – если string1 больше string2;<br> отрицательное значение – если string1 меньше string2;<br> нулевое значение – если string1 совпадает с string2;</p>
<p>Функции объединения (конкатенации) строк:</p>
<div class="page_code_style">char * strcat(char * restrict dst, const char * restrict src);<br> char * strncat(char * restrict dst, const char * restrict src, size_t num);</div>
<p>Функции поиска символа в строке:</p>
<div class="page_code_style">char * strchr(const char *string, int c);<br> char * strrchr(const char *string, int c);</div>
<p>Функция поиска строки в строке:<br> <span class="page_code_style">char * strstr(const char *str, const char *substr);</span></p>
<p>Пример:</p>
<div class="page_code_style">char str[] = "Строка для поиска";<br> char *str1 = strstr(str,"для"); //str1 == "для поиска"</div>
<p>Функция поиска первого символа в строке из заданного набора символов:<br> <span class="page_code_style">size_t strcspn(const char *str, const char *charset);</span></p>
<p>Функции поиска первого символа в строке не принадлежащему заданному набору символов:<br> <span class="page_code_style">size_t strspn(const char *str, const char *charset);</span></p>
<p>Функции поиска первого символа в строке из заданного набора символов:<br> <span class="page_code_style">char * strpbrk(const char *str, const char *charset);</span></p>
<p>Функция поиска следующего литерала в строке:<br> <span class="page_code_style">char * strtok(char * restrict string, const char * restrict charset);</span></p></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>