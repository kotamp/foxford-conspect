<!doctype html>
<html><head><link rel="stylesheet" href="../page.css"><title>17. Алгоритм поиска в глубину</title></head><body><h1>17. Алгоритм поиска в глубину</h1>
<div class="page_content_main"><p><strong>Алгоритм поиска (или обхода) в глубину</strong>&nbsp;(англ. depth-first search, DFS) позволяет построить обход ориентированного или неориентированного графа, при котором посещаются все вершины, доступные из начальной вершины.</p>
<p>Отличие поиска в глубину от поиска в ширину заключается в том, что (в случае неориентированного графа) результатом алгоритма поиска в глубину является некоторый маршрут, следуя которому можно обойти последовательно все вершины графа, доступные из начальной вершины. Этим он принципиально отличается от поиска в ширину, где одновременно обрабатывается множество вершин, в поиске в глубину в каждый момент исполнения алгоритма обрабатывается только одна вершина. С другой стороны, поиск в глубину не находит кратчайших путей, зато он применим в ситуациях, когда граф неизвестен целиком, а исследуется каким-то автоматизированным устройством.</p>
<p>Если же граф ориентированный, то поиск в глубину строит дерево путей из начальной вершины во все доступные из нее.</p>
<p>Обход в глубину можно представить себе следующим образом. Пусть исследователь находится в некотором лабиринте (графе) и он хочет обойти весь лабиринт (посетить все доступные вершины в графе). Исследователь находится в некоторой вершине и видит ребра, исходящие из этой вершины. Очевидная последовательность действий исследователя такая:</p>
<ol>
<li>Пойти в какую-нибудь смежную вершину.</li>
<li>Обойти все, что доступно из этой вершины.</li>
<li>Вернуться в начальную вершину.</li>
<li>Повторить алгоритм для всех остальных вершин, смежных из начальной.</li>
</ol>
<p>Видим, что алгоритм является рекурсивным — для обхода всего графа нужно переместиться в соседнюю вершину, после чего повторить для этой вершины алгоритм обхода. Но возникает проблема зацикливания — если из вершины A можно перейти в вершину B, то из вершины B можно перейти в вершину A и рекурсия будет бесконечной. Для борьбы с рекурсией нужно применить очень простую идею — исследователь не должен идти в ту вершину, в которой он уже был раньше, то есть которая не представляет для него интерес (считаем, что интерес для исследователя представляют только вершины, в которых он не был ранее). Итак, уточненный алгоритм может выглядеть следующим образом:</p>
<ol>
<li>Пойти в какую-нибудь смежную вершину, не посещенную ранее.</li>
<li>Запустить из этой вершины алгоритм обхода в глубину</li>
<li>Вернуться в начальную вершину.</li>
<li>Повторить пункты 1-3 для всех не посещенных ранее смежных вершин.</li>
</ol>
<p>Для реализации алгоритма понадобится отмечать, в каких вершинах был исследователь, а в каких — нет. Пометку будем делать в списке visited, где visited[i] == True для посещенных вершин, и visited[i] == false для непосещенных. Пометка «о посещении вершиных» ставится при заходе в эту вершину.</p>
<p>Поскольку целью обхода в глубину зачастую является построение дерева обхода в глубину, то сразу же будем хранить предшественника для каждой вершины.</p>
<p>Алгоритм обхода в глубину оформим в виде рекурсивной функции dfs, где start — номер вершины, из которой запускается обход.</p>
<h3>Пример реализации на языке C++</h3>
<div class="page_code_style">
<p>void dfs(int start, vector&lt;bool&gt; &amp; visited, vector &lt;int&gt; &amp; prev,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const vector &lt;vector &lt;int&gt; &gt; g)<br>{<br>&nbsp; &nbsp; visited[start] = true;<br>&nbsp; &nbsp; for (auto u : g[start])<br>&nbsp; &nbsp; &nbsp; &nbsp; if (!visited[u]) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev[u] = start;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dfs(u, visited, prev, g);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>}</p>
<p>int main()<br>{<br>&nbsp;&nbsp;&nbsp; …<br>&nbsp;&nbsp;&nbsp; vector &lt;bool&gt; visited(n + 1);<br>&nbsp;&nbsp;&nbsp; vector &lt;int&gt; prev(n + 1, -1);<br>&nbsp;&nbsp;&nbsp; dfs(start, visited, prev, g);</p>
</div>
<h3>Пример реализации на языке Python</h3>
<div class="page_code_style">
<p>visited = [False] * (n + 1)<br>prev = [None] * (n + 1)<br><br>def dfs(start, visited, prev, g):<br>&nbsp; &nbsp; visited[start] = True<br>&nbsp; &nbsp; for u in g[start]:<br>&nbsp; &nbsp; &nbsp; &nbsp; if not visited[u]:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev[u] = start&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dfs(u)<br><br>dfs(start, visited, prev, g)</p>
</div>
<p>В этом алгоритме n – число вершин в графе, вершины нумеруются числами от 1 до n, а v[u] хранит множество вершин смежных с u. Для запуска алгоритма, например, для вершины с номером start необходимо вызвать dfs. После этого вызова все вершины, доступные из start, будут отмечены в списке visited, а при помощи списка prev можно построить пути из вершины start до всех доступных вершин. Если не требуется строить дерево обхода в глубину, то можно убрать заполнение списка start, в этом случае алгоритм dfs становится чрезвычайно простым.</p><h1>Выделение компонент связности</h1>
<p>Алгоритм обхода в глубину позволяет решать множество различных задач. Например, реализуем при помощи алгоритма обхода в глубину подсчет числа компонент связности в неориентированном графе.</p>
<p>Для этого будем обходить все вершины графа и проверять, была ли очередная вершина посещена ранее. Если не была – то это означает, что найдена новая компонента связности, для выделения всей компоненты связности необходимо запустить DFS от этой вершины.</p>
<h3>Пример реализации на языке C++</h3>
<div class="page_code_style">
<p>void dfs(int start, vector&lt;bool&gt; &amp; visited, const vector &lt;vector &lt;int&gt; &gt; g)<br>{<br>&nbsp; &nbsp; visited[start] = true;<br>&nbsp; &nbsp; for (auto u : g[start])<br>&nbsp; &nbsp; &nbsp; &nbsp; if (!visited[u])<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dfs(u, visited, g);<br>}</p>
<p>int main()<br>{<br>&nbsp;&nbsp;&nbsp; …<br>&nbsp;&nbsp;&nbsp; vector &lt;bool&gt; visited(n + 1);<br>&nbsp;&nbsp;&nbsp; int ncomp = 0;<br>&nbsp;&nbsp;&nbsp; for (i = 1; i &lt;= n; ++i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!visited[i]) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++ncomp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(start, visited, g);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
</div>
<h3>Пример реализации на языке Python</h3>
<div class="page_code_style">
<p>Visited = [False] * (n + 1)<br><br>def DFS(start):<br>&nbsp; &nbsp; Visited[start] = True<br>&nbsp; &nbsp; for v in V[start]:<br>&nbsp; &nbsp; &nbsp; &nbsp; if not Visited[v]:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DFS(v)<br><br>ncomp = 0<br>for i in range(1, n + 1):&nbsp;<br>&nbsp; &nbsp; if not Visited(i):<br>&nbsp; &nbsp; &nbsp; &nbsp; ncomp += 1<br>&nbsp; &nbsp; &nbsp; &nbsp; DFS(i)</p>
</div><h1>Проверка графа на двудольность</h1>
<p>Граф называется двудольным, если его вершины можно разбить на два множества так, что концы каждого ребра принадлежат разным множествам. Иными словами, можно покрасить вершины графа в два цвета так, что концы каждого ребра покрашены в разный цвет.</p>
<p>Модифицируем алгоритм DFS так, что он будет проверять граф на двудольность и строить покраску графа в два цвета (если он двудольный). Для этого заменим список Visited на список Color, в котором будем хранить значение 0 для непосещенных вершин, а для посещенных вершин будем гранить значение 1 или 2 – ее цвет.</p>
<p>Алгоритм DFS для каждого ребра будет проверять цвет конечной вершины этого ребра. Если вершина не была посещена, то она красится в цвет, неравный цвету текущей вершины. Если же вершина была посещена, то ребро либо пропускается, если его концы – разноцветные, а если его концы одного цвета, то делается пометка, что граф не является двудольным (переменной IsBipartite присваивается значение False, по ее значению можно судить о том, является ли граф двудольный).</p>
<h3>Пример реализации на языке C++</h3>
<div class="page_code_style">
<p>bool is_bipartite = true;<br><br>void dfs(int start, vector&lt;int&gt; &amp; color, const vector &lt;vector &lt;int&gt; &gt; g)<br>{<br>&nbsp; &nbsp; for (auto u : g[start])<br>&nbsp; &nbsp; &nbsp; &nbsp; if (color[u] == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color[u] = 3 - color[start]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dfs(u, color, g);<br>}</p>
<p><br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; …<br>&nbsp;&nbsp;&nbsp; vector &lt;int&gt; color(n + 1);<br>&nbsp;&nbsp;&nbsp; for (i = 1; i &lt;= n; ++i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (color[i] == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++ncomp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(start, color, g);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
</div>
<h3>Пример реализации на языке Python</h3>
<div class="page_code_style">
<p>Color = [0] * (n + 1)<br>IsBipartite = True<br><br>def DFS(start):<br>&nbsp; &nbsp; for u in V[start]:<br>&nbsp; &nbsp; &nbsp; &nbsp; if Color[u] == 0:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Color[u] = 3 - Color[start]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DFS(u)&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; else if Color[u] == Color[start]:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsBipartite = False&nbsp;<br><br>for i in range(1, n + 1):&nbsp;<br>&nbsp; &nbsp; if Color[i] == 0:&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; Color[i] = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DFS(i)</p>
</div>
<p>Основная программа проходит по всем ребрам графа и при обнаружении ранее не обнаруженной вершины красит ее в цвет 1 и запускает DFS из этой вершины.</p><h1>Поиск цикла в ориентированном графе</h1>
<p>Цикл в ориентированном графе можно обнаружить по наличию ребра, ведущего из текущей вершины в вершину, которая в настоящий момент находится в стадии обработки, то есть алгоритм DFS зашел в такую вершину, но еще не вышел из нее. В таком алгоритме DFS будем красить вершины в три цвета. Цветом 0 («белый») будем обозначать еще непосещенные вершины. Цветом 1 («серый») будем обозначать вершины в процессе обработки, а цветом 2 («черный») будем обозначать уже обработанные вершины. Вершина красится в цвет 1 при заходе в эту вершину и в цвет 2 – при выходе. Цикл в графе существует, если алгоритм DFS обнаруживает ребро, конец которого покрашен в цвет 1.</p>
<h3>Пример реализации на языке C++</h3>
<div class="page_code_style">
<p>bool cycle_found = false;<br><br>void dfs(int start, vector&lt;int&gt; &amp; color, const vector &lt;vector &lt;int&gt; &gt; g)<br>{<br>&nbsp;&nbsp;&nbsp; color[start] = 1;<br>&nbsp; &nbsp; for (auto u : g[start])<br>&nbsp; &nbsp; &nbsp; &nbsp; if (color[u] == 0)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dfs(u, color, g);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (color[start] == 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cycle_found = true;<br>&nbsp;&nbsp;&nbsp; color[start] = 2;<br>}</p>
<p><br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; …<br>&nbsp;&nbsp;&nbsp; vector &lt;int&gt; color(n + 1);<br>&nbsp;&nbsp;&nbsp; for (i = 1; i &lt;= n; ++i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (color[i] == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(start, color, g);</p>
</div>
<h3>Пример реализации на языке Python</h3>
<div class="page_code_style">
<p>Color = [0] * (n + 1)<br>CycleFound = False<br><br>def DFS(start):<br>&nbsp; &nbsp; Color[start] = 1<br>&nbsp; &nbsp; for u in V[start]:<br>&nbsp; &nbsp; &nbsp; &nbsp; if Color[u] == 0:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DFS(u)<br>&nbsp; &nbsp; &nbsp; &nbsp; elif Color[start] == 1:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CycleFound = True&nbsp;<br>&nbsp; &nbsp; Color[start] = 2</p>
<p><br>for i in range(1, n + 1):</p>
<p>&nbsp; &nbsp; if Color[i] == 0:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; DFS(i)</p>
</div><h1>Топологическая сортировка</h1>
<p>Наконец, еще одно важное применение поиска в глубину – топологическая сортировка. Пусть дан ориентированный граф не содержащий циклов. Тогда вершины этого графа можно упорядочить так, что все ребра будут идти от вершин с меньшим номером к вершинам с большим номером.</p>
<p>Для топологической сортировки графа достаточно запустить алгоритм DFS, при выходе из вершины добавляя вершину в конец списка с ответом. После окончания алгоритма список с ответом развернуть в противоположном порядке.</p>
<h3>Пример реализации на языке C++</h3>
<div class="page_code_style">
<p>void dfs(int start, vector &lt;bool&gt; &amp; visited, vector &lt;bool&gt; &amp; ans, const vector &lt;vector &lt;int&gt; &gt; g)<br>{<br>&nbsp;&nbsp;&nbsp; visited[start] = true;<br>&nbsp; &nbsp; for (auto u : g[start])<br>&nbsp; &nbsp; &nbsp; &nbsp; if (!visited[u])<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dfs(u, visited, ans, g);<br>&nbsp;&nbsp;&nbsp; ans.push_back(start);<br>}</p>
<p><br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; …<br>&nbsp;&nbsp;&nbsp; vector &lt;bool&gt; visited(n + 1);<br>&nbsp;&nbsp;&nbsp; vector &lt;int&gt; ans;<br>&nbsp;&nbsp;&nbsp; for (i = 1; i &lt;= n; ++i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!visited[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(start, visited, ans, g);<br>&nbsp;&nbsp;&nbsp; reverse(ans.begin(), ans.end());</p>
</div>
<h3>Пример реализации на языке Python</h3>
<div class="page_code_style">
<p>Visited = [False] * (n + 1)<br>Ans = []</p>
<p>def DFS(start):<br>&nbsp; &nbsp; Visited[start] = True<br>&nbsp; &nbsp; for u in V[start]:<br>&nbsp; &nbsp; &nbsp; &nbsp; if not Visited[u]:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DFS(u)<br>&nbsp; &nbsp; Ans.append(start)</p>
<p><span><br>for i in range(1, n + 1):&nbsp;</span></p>
<p>&nbsp; &nbsp; if not Visited(i):&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; DFS(i)&nbsp;<br>Ans = Ans[::-1]</p>
</div><h1>Поиск мостов</h1>
<p>Мостом называется ребро, при удалении которого граф распадается на две компоненты связности.</p>
<p>Алгоритм поиска в глубину позволяет найти все мосты в связном графе за один DFS, то есть за сложность <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.977ex" height="2.776ex" viewBox="0 -817.1 2143 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4F" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="763" y="0"></use><use xlink:href="#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="#MJMAIN-29" x="1753" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1">O(n)</script>.</p>
<p>Подвесим граф за какую-то вершину, запустим из этой вершины DFS. DFS построит дерево обхода графа, при этом будут найдены <em>обратные рёбра</em> - рёбра, которые идут из текущей вершины в вершину, которая находится в настоящий момент в стадии обработки. Каждой вершине <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>u</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.611ex" viewBox="0 -566.3 572.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-75" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>u</mi></math></span></span><script type="math/tex" id="MathJax-Element-2">u</script> сопоставим значение <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>h</mi><mo stretchy=&quot;false&quot;>(</mo><mi>u</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.478ex" height="2.776ex" viewBox="0 -817.1 1928 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-68" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="576" y="0"></use><use xlink:href="#MJMATHI-75" x="966" y="0"></use><use xlink:href="#MJMAIN-29" x="1538" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>h</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-3">h(u)</script> — её глубина в дереве обхода.</p>
<p>Кроме этого, каждой вершине сопоставим значение функции <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>u</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.418ex" height="2.776ex" viewBox="0 -817.1 1902 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-66" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="550" y="0"></use><use xlink:href="#MJMATHI-75" x="940" y="0"></use><use xlink:href="#MJMAIN-29" x="1512" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-4">f(u)</script>, где <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>u</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.418ex" height="2.776ex" viewBox="0 -817.1 1902 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-66" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="550" y="0"></use><use xlink:href="#MJMATHI-75" x="940" y="0"></use><use xlink:href="#MJMAIN-29" x="1512" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-5">f(u)</script> - это минимальное значение <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>h</mi><mo stretchy=&quot;false&quot;>(</mo><mi>v</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.276ex" height="2.776ex" viewBox="0 -817.1 1841 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-68" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="576" y="0"></use><use xlink:href="#MJMATHI-76" x="966" y="0"></use><use xlink:href="#MJMAIN-29" x="1451" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>h</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-6">h(v)</script> для всех вершин <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>v</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.611ex" viewBox="0 -566.3 485.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-76" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>v</mi></math></span></span><script type="math/tex" id="MathJax-Element-7">v</script>, которые достижимы из вершины <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>u</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.611ex" viewBox="0 -566.3 572.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-75" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>u</mi></math></span></span><script type="math/tex" id="MathJax-Element-8">u</script> в дереве обхода, а также достижимы при помощи прохода по одному обратному ребру из любого потомка <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>u</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.611ex" viewBox="0 -566.3 572.5 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-75" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>u</mi></math></span></span><script type="math/tex" id="MathJax-Element-9">u</script> в дереве обхода.</p>
<p>Тогда ребро <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>u</mi><mi>v</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.457ex" height="1.611ex" viewBox="0 -566.3 1058 693.7" role="img" focusable="false" style="vertical-align: -0.296ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-75" x="0" y="0"></use><use xlink:href="#MJMATHI-76" x="572" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>u</mi><mi>v</mi></math></span></span><script type="math/tex" id="MathJax-Element-10">uv</script> будет мостом, если <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>v</mi><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;gt;</mo><mi>h</mi><mo stretchy=&quot;false&quot;>(</mo><mi>u</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.792ex" height="2.776ex" viewBox="0 -817.1 5077.1 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-66" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="550" y="0"></use><use xlink:href="#MJMATHI-76" x="940" y="0"></use><use xlink:href="#MJMAIN-29" x="1425" y="0"></use><use xlink:href="#MJMAIN-3E" x="2092" y="0"></use><use xlink:href="#MJMATHI-68" x="3149" y="0"></use><use xlink:href="#MJMAIN-28" x="3725" y="0"></use><use xlink:href="#MJMATHI-75" x="4115" y="0"></use><use xlink:href="#MJMAIN-29" x="4687" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>h</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-11">f(v) > h(u)</script>.</p>
<p>Значения <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>h</mi><mo stretchy=&quot;false&quot;>(</mo><mi>u</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.478ex" height="2.776ex" viewBox="0 -817.1 1928 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-68" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="576" y="0"></use><use xlink:href="#MJMATHI-75" x="966" y="0"></use><use xlink:href="#MJMAIN-29" x="1538" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>h</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-12">h(u)</script> и <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>u</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.418ex" height="2.776ex" viewBox="0 -817.1 1902 1195.3" role="img" focusable="false" style="vertical-align: -0.878ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-66" x="0" y="0"></use><use xlink:href="#MJMAIN-28" x="550" y="0"></use><use xlink:href="#MJMATHI-75" x="940" y="0"></use><use xlink:href="#MJMAIN-29" x="1512" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-13">f(u)</script> можно считать одним DFS.</p>
<h3>Пример реализации на языке C++:</h3>
<div class="page_code_style">
<p><span>void dfs(int u, int parent, </span><span><span>int curr_h, </span>vector &lt;vector&lt;int&gt; &gt; &amp; g, vector &lt;bool&gt; &amp; visited, vector&lt;int&gt; &amp; h, vector&lt;int&gt; &amp; f)<br>{<br>&nbsp;&nbsp;&nbsp; h[u] = curr_h++;<br>&nbsp;&nbsp;&nbsp; f[u] = h[u];<br>&nbsp;&nbsp;&nbsp; visited[u] = true;<br>&nbsp;&nbsp;&nbsp; for (auto v : g[u])<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>if (v == parent)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!visited[v])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(v, u, </span><span><span>curr_h, </span>g, visited, h, f);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f[u] = min(f[u], f[v]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (f[v] &gt; h[u])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { // Найден мост u-v<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f</span><span>[u] = min(f[u], h[v]);<br>&nbsp;&nbsp;&nbsp; </span><span>}<br>}</span></p>
</div>
<p>Параметры, передаваемые в функцию:</p>
<p><span class="page_code_style">u</span> - текущая вершина</p>
<p><span class="page_code_style">parent</span> - родитель, чтобы не проходить по ребру в обратном направлении (эта реализация не работает на графе с кратными ребрами).</p>
<p><span class="page_code_style">curr_h</span> - текущая глубина</p>
<p><span class="page_code_style">g</span> - списки смежности графа</p>
<p><span class="page_code_style">h</span> - массив значений глубины для вершин</p>
<p><span class="page_code_style">f</span> - массив значения целевой функции для вершин</p></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>